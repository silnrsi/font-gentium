/*
    Title:   Roman Font GDL description
    Authors: Martin Hosken, Bob Halllissy, Joan Wardell, Sharon Correll


	This file is part of Charis font family
	(http://scripts.sil.org/CharisSIL) and is
	Copyright (c) 2003-2010 SIL International (http://www.sil.org/),
	with Reserved Font Names "Charis" and "SIL".

	This Font Software is licensed under the SIL Open Font License,
	Version 1.1.

	You should have received a copy of the license along with this Font Software.
	If this is not the case, go to (http://scripts.sil.org/OFL) for all the
	details including a FAQ.


    Changes:
AKW 2013-Mar-05  Remove Deprecated PUA feature
SJC 2008-Oct     More changes for ditto
SJC 2008-Aug-26  Various changes for small-caps, deprecated PUA, etc.
SJC 2008-Apr-23  Changed Tat alternates back to H-stroke alternates
SJC 2008-Apr-15  Patch (kludge) to handle dotless i w/ alternate tail
AKW 2008-Apr-02  Restore hookabove glyphs to Vietnamese diacritic classes
SJC 2007-Oct-31  Added #ifs for Gentium Basic and Gentium Book Basic
SJC 2007-Jan-26  Cleaned up distinction between Open-O alternates and J-stroke-hook-alternate
SJC 2006-Dec-4   Various changes for new version to support Unicode 5.0:
	Changed VNStyle to vN; added Chinantec tones, Cyrillic cursive italics, open-o serif feature
SJC 2006 ??????  Added barred-j modifier to take smaller diacritics; added smallcaps code (turned off)
SJC 2006-Apr-6   Allow ogonek and literacy rules to both fire
SJC 2006-Mar-21  Handle literacy alternates + Vietnamese diacritics for NFC data
SJC 2006-Jan-23  Added Cyrillic shha alternate
SJC 2005-Oct-14  Added slant-italic ff, fi, fl ligatures
SJC 2005-Oct-13  Made ff, fi, fl true ligatures with components.
SJC 2005-Oct-12  Fixed problems with dotted modifier super/subscripts and partial fix for F17A (double diaeresis).
SJC 2005-Sep-1   Added slant-italic special forms, diaersis on superscripts, and bridging diacritics.
SJC 2005-May-16  Handle features modlowcolon, ltnglottalstop, and ltnjstroke.
SJC 2005-May-16  Turn off AutoPseudo.
SJC 2005-May-10  Added a few comments.
AKW 2005-May-09  Changed gF176 to g035C (PUA character accepted into Unicode).
JMW 2004-Sep-02  For now, I will take easy option on fixing Literacy Alts and Romanian,
    by backing up. Later I may re-write. Input to WP2 is now NFD, necessitating a change.
JMW 2004-Jul-21  Comments on Viet, add 4th Eng.
RMH 2004-Mar-17  Changed logic for ou alternates due to default is now closed top,
	and alternate is .OpenType  (issue RFS-5WXH4D);
	added omacron and Omacron to things that can composite with ogonek (related to issue RFS-5X5FKC);
	renamed cnDia to cDia -- it is a class of all diacritics, not the class of non-diacritics;
	added cHDia to cBDia, but I think the cBDia and cnBDia classes aren't used...?
RMH 2004-Feb-25  removed all smartcode that builds alternates (of composites) by decomposition
	(we now have real alternates available in the font);
	in the process, eliminated viet.gdh -- integrating it directly here.
RMH 2004-Feb-13  Made explicit associations to quiet new GrCompiler warnings.
RMH 2004-Feb-05  Rewrote rules that had been generated by normal_rules() function in makegdl.pl so
	that (1) only those glyphs that need composition (things with ogonek, cedilla, horn)
	are actually composed, and (2) now permits other diacritcs to intervene.
	Similarly added code to permit intevening diacs in rules for .vNStyle diac ligatures.
RMH 2004-Feb-04 Changes after B14: implemented logic for retrohookstyle ogonek alternates feature.
RMH 2004-Jan-19 Changes after B10: omehow p_hook feature wasn't ever implemented.
RMH 10-Oct-2003 Significant rework:
	added "else" clauses for most features (so this same code works if
	Feature table and cmap are changed so an "alternate" glyph is the default);
	added code to handle cedillas that need to be rendered as commaaccent;
	added DeBuG feature (only compiled in if symbol DEBUG is defined as non-zero).
RMH 01-Sep-2003 Reworked all features per PC's design.
RMH 15-Aug-2003  Added other Unicode 4.0 double-diacritics;
    fixed double diacritic positioning so not dependent on glyph's default location
	(requires double diacritics should NOT have attachment points).
RMH 17-Jul-2003  Removed all references to "P" and "_P" attachment points -- it no longer exists;
    replace refs to U+F177 with U+035E (Unicode 4.0).
RMH 10-Jul-2003  Added logic to decompose 1E2D and 1ECB in the context of upper diacritics.
MJPH 16-Nov-2002 Move overarch to down by -1200m from -700m.
*/

#include "stddef.gdh"

#define CHARISfont 1
#define DOULOSfont 2
#define GENTIUMBASICfont 3
#define GENTIUMBOOKBASICfont 4
#define GENTIUMfont 5
#define GENTIUMBOOKfont 6
#define ANDIKABASICfont 7
#define ANDIKAfont 8

/////#define GENBASICfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont)
#define BASIC (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == ANDIKABASICfont)
#define ANDIKAfamily (FONT == ANDIKAfont || FONT == ANDIKABASICfont)
#define GENTIUMfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == GENTIUMfont || FONT == GENTIUMBOOKfont)

// Now turn on the font we want, so we get specific features. (This file is copied from
// something like doulos.gdh or charis.gdh by the build process.)
#include "fontSpecific.gdh"

#define DEBUG 0
// #define DEBUG 1  //jw 7/21/04 Use this to turn on DEBUG

#define SMALLCAPS 0

Bidi = 0;

// We handle double-encoded glyphs by hand, for the deprecated-PUA feature.
AutoPseudo = 0;

#define DIASTR3(x) [ x [ x x?]?]?
#define DIASTR4(x) [ x [ x [ x x?]?]?]?
#define DIASTR5(x) [ x [ x [ x [ x x?]?]?]?]?
#define attached	user1

// user1 - user4 are used in pitches.gdh
// user1 is used by both pitch and attachment stuff because there should not be any conflict.
// user2 is used by both pitch and low-profile stuff because there should not be any conflict.

#define needs_lp	user2

// #define pua		user5

#define LP_DIACONLY 0
#define LP_BASEONLY 1
#define LP_BASEDIAC 2

////#define KERNPASS 3

#if DEBUG
#define DeBuG g__ltn_cap_d g__ltn_sm_e g__ltn_cap_b g__ltn_sm_u g__ltn_cap_g g__colon
#endif

//////////////////////////////////////////////////////////////////////////////////////
//
//	Glyphs
//

table(glyph);

// To make upstream whitespace be reordered at the end of a line; shouldn't be
// needed if compiler is working correctly.
//clsSpaces = (g_space, g2000, g2001, g2002, g2003, g2004, g2005
//				g2006, g2007, g2008, g2009, g200A, g200B)
//			{ dir = DIR_WHITESPACE };


// Temp additions by David Raymond

// cBarBowl = (g__ltn_sm_b_barred_bowl, g__ltn_sm_d_barred_bowl, g__ltn_sm_g_barred_bowl);

// cno_BarBowl = (g__ltn_sm_b_barred_stem, g__ltn_sm_d_barred_stem, g__ltn_sm_g_strk);



// Additions to feature classes for small caps; these are not included
// automatically by make_gdl.

cBaselineHook += (g__ltn_sm_eng_baseline_hook_sc); // but these classes aren't really used
cUCStyle += (g__ltn_sm_eng_u_c_style_sc);
cKom += (g__ltn_sm_eng_kom_sc);
cno_BaselineHook += (g__ltn_sm_eng_sc);
cno_UCStyle += (g__ltn_sm_eng_sc);
cno_Kom += (g__ltn_sm_eng_sc);

// This class is not useful since there are two different features that use "topBar":
//cTopBar += (g0253_topBar_sc);
//cno_TopBar += (g0253_sc);

cTopBarB = (g__ltn_sm_b_hook_top_bar, g__ltn_cap_b_hook_top_bar, g__ltn_sm_b_hook_top_bar_sc);
cno_TopBarB = (g__ltn_sm_b_hook, g__ltn_cap_b_hook, g__ltn_sm_b_hook_sc);

cTopBarD = (g__ltn_cap_d_hook_top_bar, g__ltn_sm_d_hook_top_bar_sc);
cno_TopBarD = (g__ltn_cap_d_hook, g__ltn_sm_d_hook_sc);

cVertStrk += (g__ltn_sm_h_strk_vert_strk_sc);
cno_VertStrk += (g__ltn_sm_h_strk_sc);

//cCommaStyle += (g_scedilla_comma_style_sc, g0163_commaStyle_sc);
//cno_CommaStyle += (g_scedilla_sc, g0163_sc);

cTopSerif += (g__ltn_sm_opn_o_top_serif_sc);
cno_TopSerif += (g__ltn_sm_opn_o_sc);

cLCStyleNhook = (g__ltn_cap_n_lft_hook_l_c_style, g__ltn_sm_n_lft_hook_l_c_style_sc);
cno_LCStyleNhook = (g__ltn_cap_n_lft_hook, g__ltn_sm_n_lft_hook_sc);

cLCStyleRtail = (g__ltn_cap_sm_r_hook_tail, g__ltn_sm_cap_sm_r_hook_tail); // what about lowercase r-tail SC?
cno_LCStyleRtail = (g__ltn_cap_r_hook_tail, g__ltn_sm_r_hook_tail_sc);

cRtHookThook = (g__ltn_cap_t_hook_rt_hook, g__ltn_sm_t_hook_rt_hook_sc);
cno_RtHookThook = (g__ltn_cap_t_hook, g__ltn_sm_t_hook_sc);

cRtHookYhook = (g__ltn_cap_y_hook_rt_hook, g__ltn_sm_y_hook_rt_hook_sc);
cno_RtHookYhook = (g__ltn_cap_y_hook, g__ltn_sm_y_hook_sc);

cStraightLft += (g__ltn_sm_v_hook_straight_lft_sc);
cStraightLftHighHook += (g__ltn_sm_v_hook_straight_lft_high_hook_sc);
cno_StraightLft += (g__ltn_sm_v_hook_sc);
cno_StraightLftHighHook += (g__ltn_sm_v_hook_sc);

cRevSigmaStyle += (g__cy_sm_abkhas_dze_rev_sigma_style_sc, g__ltn_sm_ezh_rev_sigma_style_sc);
cno_RevSigmaStyle += (g__cy_sm_abkhas_dze_sc, g__ltn_sm_ezh_sc);

cOpenTop += (g__ltn_sm_ou_open_top_sc);
cno_OpenTop += (g__ltn_sm_ou_sc);

cMongolStyle += (g__cy_sm_e_mongol_style_sc);
cno_MongolStyle += (g__cy_sm_e_sc);

cLrg += (g__ltn_sm_saltillo_lrg_sc);
cno_Lrg += (g__ltn_sm_saltillo_sc);

cRetroHook += (
		g__ltn_sm_a_ogonek_retro_hook_sc,	g__ltn_sm_a_ogonek_sng_story_retro_hook_sc,	g__ltn_sm_e_ogonek_retro_hook_sc,
		g__ltn_sm_i_ogonek_retro_hook_sc,	g__ltn_sm_u_ogonek_retro_hook_sc, 			g__ltn_sm_o_ogonek_retro_hook_sc,			g__ltn_sm_o_ogonek_macron_retro_hook_sc);
cno_RetroHook += (
		g__ltn_sm_a_ogonek_sc,					g__ltn_sm_a_ogonek_sng_story_sc,			g__ltn_sm_e_ogonek_sc,
		g__ltn_sm_i_ogonek_sc,					g__ltn_sm_u_ogonek_sc,					g__ltn_sm_o_ogonek_sc,					g__ltn_sm_o_ogonek_macron_sc);



cVN += (g__ltn_sm_a_circum_acute_v_n_sc,	g__ltn_sm_a_circum_grave_v_n_sc,	g__ltn_sm_a_circum_tilde_v_n_sc,	g__ltn_sm_a_circum_hook_abv_v_n_sc,
		g__ltn_sm_a_breve_acute_v_n_sc,	g__ltn_sm_a_breve_grave_v_n_sc,	g__ltn_sm_a_breve_tilde_v_n_sc,	g__ltn_sm_a_breve_hook_abv_v_n_sc,
		g__ltn_sm_a_circum_acute_sng_story_v_n_sc,	g__ltn_sm_a_circum_grave_sng_story_v_n_sc,	g__ltn_sm_a_circum_tilde_sng_story_v_n_sc,	g__ltn_sm_a_circum_hook_abv_sng_story_v_n_sc,
		g__ltn_sm_a_breve_acute_sng_story_v_n_sc,	g__ltn_sm_a_breve_grave_sng_story_v_n_sc,	g__ltn_sm_a_breve_tilde_sng_story_v_n_sc,	g__ltn_sm_a_breve_hook_abv_sng_story_v_n_sc,
		g__ltn_sm_e_circum_acute_v_n_sc,	g__ltn_sm_e_circum_grave_v_n_sc,	g__ltn_sm_e_circum_tilde_v_n_sc,	g__ltn_sm_e_circum_hook_abv_v_n_sc,	g__ltn_sm_o_circum_acute_v_n_sc,	g__ltn_sm_o_circum_grave_v_n_sc,	g__ltn_sm_o_circum_tilde_v_n_sc,	g__ltn_sm_o_circum_hook_abv_v_n_sc);

cno_VN += (g__ltn_sm_a_circum_acute_sc,	g__ltn_sm_a_circum_grave_sc,		g__ltn_sm_a_circum_tilde_sc,		g__ltn_sm_a_circum_hook_abv_sc,
		g__ltn_sm_a_breve_acute_sc,		g__ltn_sm_a_breve_grave_sc,		g__ltn_sm_a_breve_tilde_sc,		g__ltn_sm_a_breve_hook_abv_sc,
		g__ltn_sm_a_circum_acute_sng_story_sc,		g__ltn_sm_a_circum_grave_sng_story_sc,		g__ltn_sm_a_circum_tilde_sng_story_sc,		g__ltn_sm_a_circum_hook_abv_sng_story_sc,
		g__ltn_sm_a_breve_acute_sng_story_sc,		g__ltn_sm_a_breve_grave_sng_story_sc,		g__ltn_sm_a_breve_tilde_sng_story_sc,		g__ltn_sm_a_breve_hook_abv_sng_story_sc,
		g__ltn_sm_e_circum_acute_sc,		g__ltn_sm_e_circum_grave_sc,		g__ltn_sm_e_circum_tilde_sc,		g__ltn_sm_e_circum_hook_abv_sc,		g__ltn_sm_o_circum_acute_sc,		g__ltn_sm_o_circum_grave_sc,		g__ltn_sm_o_circum_tilde_sc,		g__ltn_sm_o_circum_hook_abv_sc);


// Why is there no g_lcaron_caron_sc??

// Give a better name:
c_sc = csc;


// Classes of double-diacritics above and below:
cUDblDia = (g__comb_dbl_breve  g__comb_dbl_macron  g__comb_dbl_tilde  g__comb_dbl_inv_breve  g__comb_dbl_diaer  g__comb_dbl_circum);
cLDblDia = (g__comb_dbl_macron_blw  g__comb_dbl_rt_arrw_blw  g__comb_dbl_breve_blw);


// Various classes of diacritics; the classes generated by make_gdl are not helpful.
cBDia = (cLDia cODia cHDia);				// Below = Lower + Ogonek + Cedilla
cnBDiaX = (cUDia cRDia);					// Not Below
cnHDiaX = (cLDia cODia cRDia cUDia);		// Not Cedilla
cnLDiaX = (cHDia cODia cRDia cUDia);		// Not Lower
cnODiaX = (cHDia cLDia cRDia cUDia);		// Not Ogonek
cnRDiaX = (cHDia cLDia cODia cUDia);		// Not Horn (right)
cnUDiaX = (cHDia cLDia cODia cRDia );		// Not Upper
cDia =  (cHDia cLDia cODia cRDia cUDia);	// Any (but not double dias)

// ff, fi, fl ligatures

cfLigC2 = (g__ltn_sm_f  g__ltn_sm_i  g__ltn_sm_l);
cfLig  = (g__ltn_lig_sm_f_sm_f  g__ltn_lig_sm_f_sm_i  g__ltn_lig_sm_f_sm_l);
cffLigC3 = (g__ltn_sm_i  g__ltn_sm_l);
cffLig = (g__ltn_lig_sm_f_sm_f_sm_i  g__ltn_lig_sm_f_sm_f_sm_l);

cfLigC2_sItal  = (g__ltn_sm_f_s_ital, g__ltn_sm_i_s_ital, g__ltn_sm_l_s_ital);
cfLig_sItal    = (g__ltn_lig_sm_f_sm_f_s_ital, g__ltn_lig_sm_f_sm_i_s_ital, g__ltn_lig_sm_f_sm_l_s_ital);
cffLigC3_sItal = (g__ltn_sm_i_s_ital, g__ltn_sm_l_s_ital);
cffLig_sItal   = (g__ltn_lig_sm_f_sm_f_sm_i_s_ital, g__ltn_lig_sm_f_sm_f_sm_l_s_ital);

cfLig_all = (cfLig  cfLig_sItal)
	{ component {f1 = box(0, -descent, aw/2, ascent); f2 = box(aw/2, -descent, aw, ascent) }};
cffLig_all = (cffLig  cffLig_sItal)
	{ component { f1 = box(0, -descent, aw/3, ascent);
					f2 = box(aw/3, -descent, (2*aw)/3, ascent);
					f3 = box((2*aw)/3, -descent, aw, ascent) }}

cSpecialDotted = (g__ltn_sm_i_tilde_blw  g__ltn_sm_i_dot_blw);		// i with lower diacritics
cSpecialDottedDia = (g__comb_tilde_blw  g__comb_dot_blw);


// Special class defs for cedilla compositions that are rendered as commaaccent:
cCedillaBase = (g__ltn_cap_g  g__ltn_sm_g  g__ltn_cap_k  g__ltn_sm_k  g__ltn_cap_l  g__ltn_sm_l  g__ltn_cap_n  g__ltn_sm_n  g__ltn_cap_r  g__ltn_sm_r);
cCedillaComposite = (g__ltn_cap_g_cedilla g__ltn_sm_g_cedilla g__ltn_cap_k_cedilla g__ltn_sm_k_cedilla
		g__ltn_cap_l_cedilla	g__ltn_sm_l_cedilla g__ltn_cap_n_cedilla g__ltn_sm_n_cedilla g__ltn_cap_r_cedilla
		g__ltn_sm_r_cedilla);

// Add in other cedilla composites:
cCedillaBase += (g__ltn_cap_c  g__ltn_sm_c  g__ltn_cap_s  g__ltn_sm_s  g__ltn_cap_t  g__ltn_sm_t  g__ltn_cap_e  g__ltn_sm_e  g__ltn_sm_s_sc  g__ltn_sm_t_sc)
cCedillaComposite += (g__ltn_cap_c_cedilla g__ltn_sm_c_cedilla g__ltn_cap_s_cedilla g__ltn_sm_s_cedilla
		g__ltn_cap_t_cedilla  g__ltn_sm_t_cedilla  g__ltn_cap_e_cedilla  g__ltn_sm_e_cedilla  g__ltn_sm_s_cedilla_sc  g__ltn_sm_t_cedilla_sc)

// Ogonek composites:
cOgonekBase = (g__ltn_cap_a  g__ltn_sm_a  g__ltn_cap_e  g__ltn_sm_e  g__ltn_cap_u  g__ltn_sm_u  g__ltn_cap_o  g__ltn_sm_o  g__ltn_cap_o_macron  g__ltn_sm_o_macron);
cOgonekComposite = (g__ltn_cap_a_ogonek g__ltn_sm_a_ogonek g__ltn_cap_e_ogonek g__ltn_sm_e_ogonek g__ltn_cap_u_ogonek
		g__ltn_sm_u_ogonek  g__ltn_cap_o_ogonek  g__ltn_sm_o_ogonek  g__ltn_cap_o_ogonek_macron  g__ltn_sm_o_ogonek_macron);

// Horn composites:
cHornBase = (g__ltn_cap_o  g__ltn_sm_o  g__ltn_cap_u  g__ltn_sm_u);
cHornComposite = (g__ltn_cap_o_horn  g__ltn_sm_o_horn  g__ltn_cap_u_horn  g__ltn_sm_u_horn);

// Modifier superscripts that require smaller diacritics:
cModSuper = (g__mod_sm_h  g__mod_sm_h_hook  g__mod_sm_j  g__mod_sm_r  g__mod_sm_trnd_r  g__mod_sm_trnd_r_hook  g__mod_sm_cap_inv_r  g__mod_sm_w  g__mod_sm_y
		g__mod_glottal_stop  g__mod_rev_glottal_stop  g__mod_sm_gamma  g__mod_sm_l  g__mod_sm_s  g__mod_sm_x  g__mod_sm_rev_glottal_stop
		g__mod_cap_a  g__mod_cap_ae  g__mod_cap_b  g__mod_cap_barred_b
		g__mod_cap_d  g__mod_cap_e  g__mod_cap_rev_e  g__mod_cap_g  g__mod_cap_h  g__mod_cap_i  g__mod_cap_j  g__mod_cap_k
		g__mod_cap_l  g__mod_cap_m  g__mod_cap_n  g__mod_cap_rev_n  g__mod_cap_o  g__mod_cap_ou  g__mod_cap_p  g__mod_cap_r
		g__mod_cap_t  g__mod_cap_u  g__mod_cap_w  g__ltn_sup_sm_a  g__ltn_sup_sm_turned_a  g__ltn_sup_sm_alpha  g__mod_sm_trnd_ae  g__ltn_sup_sm_b
		g__ltn_sup_sm_d  g__ltn_sup_sm_e  g__ltn_sup_sm_schwa  g__ltn_sup_sm_opn_e  g__mod_sm_trnd_opn_e  g__ltn_sup_sm_g  g__mod_sm_trnd_i  g__ltn_sup_sm_k
		g__ltn_sup_sm_m  g__ltn_sup_sm_eng  g__ltn_sup_sm_o  g__ltn_sup_sm_opn_o  g__mod_sm_top_half_o  g__mod_sm_bottom_half_o  g__ltn_sup_sm_p  g__ltn_sup_sm_t
		g__ltn_sup_sm_u  g__mod_sm_sdwys_u  g__ltn_sup_sm_turned_m  g__ltn_sup_sm_v  g__mod_sm_ain  g__mod_sm_beta  g__mod_sm_gr_gamma  g__mod_sm_delta  g__mod_sm_gr_phi  g__mod_sm_chi  g__mod_cy_cap_en
		g__ltn_sup_sm_turned_alpha  g__mod_sm_c  g__ltn_sup_sm_c_curl  g__mod_sm_eth  g__ltn_sup_sm_rev_opn_e
		g__ltn_sup_sm_f  g__ltn_sup_sm_dotless_j_strk  g__ltn_sup_sm_script_g  g__mod_sm_turned_h  g__ltn_sup_sm_i_strk  g__mod_sm_iota  g__ltn_sup_sm_cap_i  g__mod_sm_cap_i_strk
		g__mod_sm_j_crossed_tail  g__ltn_sup_sm_l_retr_hook  g__mod_sm_l_pal_hook  g__mod_sm_cap_l  g__mod_sm_m_hook  g__ltn_sup_sm_turned_m_lng_leg  g__ltn_sup_sm_n_lft_hook  g__mod_sm_n_retr_hook
		g__mod_sm_cap_n  g__ltn_sup_sm_barred_o  g__mod_sm_phi  g__mod_sm_s_hook  g__ltn_sup_sm_esh  g__mod_sm_t_pal_hook  g__ltn_sup_sm_u_bar  g__ltn_sup_sm_upsilon
		g__mod_sm_cap_u  g__mod_sm_v_hook  g__ltn_sup_sm_turned_v  g__ltn_sup_sm_z  g__mod_sm_z_retr_hook  g__ltn_sup_sm_z_curl  g__ltn_sup_sm_ezh  g__mod_sm_theta  g__ltn_sup_sm_i  g__ltn_sup_sm_n
		g__ltn_sup_sm_i_dotless  g__mod_sm_j_dotless  g__ltn_sup_sm_i_strk_dotless  g__mod_sm_j_crossed_tail_dotless);

// Modifier subscripts that require smaller diacritics:
cModSub = (g__ltn_sub_sm_i  g__ltn_sub_sm_r  g__ltn_sub_sm_u  g__ltn_sub_sm_v  g__gr_sub_sm_beta  g__gr_sub_sm_gamma  g__gr_sub_sm_rho  g__gr_sub_sm_phi  g__gr_sub_sm_chi
		g__ltn_sub_sm_a  g__ltn_sub_sm_e  g__ltn_sub_sm_o  g__ltn_sub_sm_x  g__ltn_sub_sm_schwa
		g__ltn_sub_sm_i_dotless);

// Vietnamese diacritic combinations

#if (FONT == GENTIUMfont)
c0302_noVN = (g__comb_circum  g__comb_circum_l_p);
#else
c0302_noVN = (g__comb_circum);
#endif

c0306_noVN = (g__comb_breve);

cDiac_noVN = (g__comb_acute		g__comb_grave		g__comb_hook_abv 	g__comb_tilde);
c_0302_DiacVN = (	g__comb_circum_acute_v_n		g__comb_circum_grave_v_n
					g__comb_circum_hook_v_n	g__comb_circum_tilde_v_n);
c_0306_DiacVN = (	g__comb_breve_acute_v_n		g__comb_breve_grave_v_n
					g__comb_breve_hook_v_n	g__comb_breve_tilde_v_n);

#if (FONT == GENTIUMfont)
cno_LP += (	g__comb_circum_acute_v_n		g__comb_circum_grave_v_n		g__comb_circum_tilde_v_n		g__comb_circum_hook_v_n
			g__comb_breve_acute_v_n		g__comb_breve_grave_v_n		g__comb_breve_tilde_v_n );
cLP += 	(	g__comb_circum_acute_v_n_l_p	g__comb_circum_grave_v_n_l_p	g__comb_circum_tilde_v_n_l_p	g__comb_circum_hook_v_n_l_p
			g__comb_breve_acute_v_n_l_p	g__comb_breve_grave_v_n_l_p	g__comb_breve_tilde_v_n_l_p );
#endif

// Precomposed base + first diac
c_baseCircum = (g__ltn_cap_a_circum, g__ltn_sm_a_circum, g__ltn_cap_e_circum, g__ltn_sm_e_circum,
				g__ltn_cap_i_circum, g__ltn_sm_i_circum, g__ltn_cap_o_circum, g__ltn_sm_o_circum,
				g__ltn_cap_u_circum, g__ltn_sm_u_circum);
c_baseBreve  = (g__ltn_cap_a_breve, g__ltn_sm_a_breve, g__ltn_cap_e_breve, g__ltn_sm_e_breve,
				g__ltn_cap_i_breve, g__ltn_sm_i_breve, g__ltn_cap_o_breve, g__ltn_sm_o_breve, g__ltn_cap_u_breve, g__ltn_sm_u_breve);
c_base_noDiac = (g__ltn_cap_a, g__ltn_sm_a, g__ltn_cap_e, g__ltn_sm_e, g__ltn_cap_i, g__ltn_sm_i, g__ltn_cap_o, g__ltn_sm_o, g__ltn_cap_u, g__ltn_sm_u);

// Vietnamese/literacy combinations

// a with stacked diacritics
c_aStack_noLit = (g__ltn_sm_a_circum_acute  g__ltn_sm_a_circum_grave  g__ltn_sm_a_circum_hook_abv  g__ltn_sm_a_circum_tilde  g__ltn_sm_a_breve_acute  g__ltn_sm_a_breve_grave  g__ltn_sm_a_breve_tilde  g__ltn_sm_a_breve_hook_abv); // eg, a+circum+acute
c_diacComb_vN = (g__comb_circum_acute_v_n, g__comb_circum_grave_v_n,
			g__comb_circum_hook_v_n, g__comb_circum_tilde_v_n,
			g__comb_breve_acute_v_n, g__comb_breve_grave_v_n,
			g__comb_breve_hook_v_n, g__comb_breve_tilde_v_n);


// These caron combinations are treated specially by European languages, which is the default:
cCaronEuro = (g__ltn_sm_d_caron, g__ltn_sm_l_caron, g__ltn_cap_l_caron, g__ltn_sm_l_caron_sc, g__ltn_sm_t_caron);
cno_CaronEuro = (g__ltn_sm_d, g__ltn_sm_l, g__ltn_cap_l, g__ltn_sm_l_sc, g__ltn_sm_t);

// These work for Doulos:
g__ltn_sm_d_caron {comp {base = box(0, bb.bottom-50m, (3*aw)/4, bb.top+50m);
                caron = box((3*aw)/4, bb.top - 450m, aw,bb.top+50m) }};

g__ltn_sm_l_caron {comp {base = box(0,bb.bottom-70m, (2*aw)/3, bb.top+50m);
                caron = box((5*aw)/8, bb.top - 450m, aw,bb.top+50m) }};

g__ltn_cap_l_caron {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-200m,bb.top+50m) }};

g__ltn_sm_l_caron_sc {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-100m,bb.top+50m) }};

g__ltn_sm_t_caron {comp {base = box(0,bb.bottom-50m, bb.right-200m, bb.top-200m);
                caron = box(bb.right-300m, bb.top-450m, bb.right+50m, bb.top+50m) }};


// Uppercase-eng variations
// (The extra composite glyphs aren't really needed, they only happen to be in the font for AAT.)
c_eng_Descender = (g__ltn_cap_eng, g__ltn_sm_eng_sc);                    // cno_BaselineHook = cno_Kom
c_eng_UCStyle = (g__ltn_cap_eng_u_c_style, g__ltn_sm_eng_u_c_style_sc);  // (g__eng_u_c_style, g014A0301_uCStyle, g014A0300_uCStyle, g014A0302_uCStyle, g014A0303_uCStyle, g014A0323_uCStyle);
c_eng_BaselineHook = (g__ltn_cap_eng_baseline_hook, g__ltn_sm_eng_baseline_hook_sc);  // cBaselineHook;
c_eng_Kom = (g__ltn_cap_eng_kom, g__ltn_sm_eng_kom_sc);                  // cKom;

// V-hook variations
c_vhook_Curved = cno_StraightLft; // = cno_StraightLftHighHook
c_vhook_StraightLeft = cStraightLft;
c_vhook_HighHook = cStraightLftHighHook;

// Cyrillic shha (uses same tag as uppercase eng so we define these clases by hand):
cUCStyleCyrShha = (g__cy_sm_shha_u_c_style);
cno_UCStyleCyrShha = (g__cy_sm_shha);

// We need to add these explicitly because makegdl does not recognize the fact that
// 'g_dotlessi_s_italic' needs to be in the cDotless class.
// TODO: recheck when we switch over to the new version of make_gdl.
cDotless += (g__ltn_sm_dotless_i_s_ital); // g_dotlessi_tail_i;
cno_Dotless += (g__ltn_sm_i_s_ital);     // g_i_tail_i;

// Same with tail-i and j-serif.
#if (ANDIKAfamily)
cDotless    += (g__ltn_sm_dotless_i_tail_i	g__ltn_sm_dotless_j_top_lft_serif);
cno_Dotless += (g__ltn_sm_i_tail_i			g__ltn_sm_j_top_lft_serif);
#endif

// Same with the low-profile i and j.
#if (FONT == GENTIUMfont)
cDotless    += (g__ltn_sm_i_dotless	g__ltn_sm_j_dotless);
cno_Dotless += (g__ltn_sm_i_l_p		g__ltn_sm_j_l_p);

// Also handle converting low-profile i/j to small caps.
cno_sc	+= (g__ltn_sm_i_l_p		g__ltn_sm_j_l_p);
c_sc	+= (g__ltn_sm_i_sc		g__ltn_sm_j_sc);
#endif

#if (ANDIKAfamily)
// makegdl can't figure out that 'g_q_diag_tail_sc' needs to be in the cDiagTail class.
cno_DiagTail += (g__ltn_sm_q_sc);
cDiagTail    += (g__ltn_sm_q_diag_tail_sc);
#endif

cno_BrInvBreve = (g__comb_inv_breve    g__comb_dbl_inv_breve);
cBrInvBreve_uU = (g__comb_inv_breve_u_u g__comb_dbl_inv_breve_u_u);
cBrInvBreve_uL = (g__comb_inv_breve_u_l g__comb_dbl_inv_breve_u_l);
cBrInvBreve_lL = (g__comb_inv_breve_l_l g__comb_dbl_inv_breve_l_l);

cBridgeDiac = ( g__comb_diaer_u_u  g__comb_diaer_u_l  g__comb_diaer_l_l
				g__comb_inv_breve_u_u  g__comb_inv_breve_u_l  g__comb_inv_breve_l_l
				g__comb_dbl_inv_breve_u_u  g__comb_dbl_inv_breve_u_l  g__comb_dbl_inv_breve_l_l);


// Narrow characters that need a narrow macron.
// Since this subsitution is done in the first pass, we only need to include encoded glyphs.

c_narrowMacron = (g__ltn_sm_i, g__ltn_sm_l, g__ltn_sm_r, g__ltn_sm_t,
	g__ltn_sm_i_grave, g__ltn_sm_i_acute, g__ltn_sm_i_circum, g__ltn_sm_i_diaer, g__ltn_sm_i_tilde, g__ltn_sm_i_macron, g__ltn_sm_i_breve, g__ltn_sm_i_ogonek, g__ltn_sm_dotless_i,
	g__ltn_sm_l_acute, g__ltn_sm_l_cedilla, g__ltn_sm_l_caron, g__ltn_sm_l_middle_dot, g__ltn_sm_l_strk,
	g__ltn_sm_r_acute, g__ltn_sm_r_cedilla, g__ltn_sm_r_caron, g__ltn_sm_t_cedilla, g__ltn_sm_t_caron, g__ltn_sm_t_strk, g__ltn_cap_iota, g__ltn_sm_l_bar, g__ltn_sm_t_hook, g__ltn_sm_i_caron, g__ltn_sm_i_dbl_grave,
	g__ltn_sm_i_inv_breve, g__ltn_sm_r_dbl_grave, g__ltn_sm_r_inv_breve, g__ltn_sm_t_comma_blw,
	g__ltn_sm_l_curl, g__ltn_sm_t_curl // l-curl, t-curl
	g__ltn_sm_r_bar, g__ltn_sm_i_strk, g__ltn_sm_iota, g__ltn_sm_l_middle_tilde, g__ltn_sm_l_belt, g__ltn_sm_l_retr_hook, g__ltn_sm_r_lng_leg, g__ltn_sm_r_fishhook, g__ltn_sm_turned_t, g__ltn_sm_t_retr_hook,
	g__ltn_sm_r_middle_tilde, g__ltn_sm_r_fishhook_middle_tilde, g__ltn_sm_t_middle_tilde, g__ltn_sm_iota_strk,
	g__ltn_sm_r_pal_hook,
	// g1e2d, g1e3d, g1e71, // i-lower-tilde, l-lower-circumflex, t-lower-circumflex
	g__ltn_sm_i_diaer_acute, g__ltn_sm_h_diaer, g__ltn_sm_l_dot_blw_macron, g__ltn_sm_l_line_blw, g__ltn_sm_r_dot_abv, g__ltn_sm_r_dot_blw, g__ltn_sm_r_dot_blw_macron, g__ltn_sm_r_line_blw, g__ltn_sm_t_dot_abv, g__ltn_sm_t_dot_blw, g__ltn_sm_t_line_blw, g__ltn_sm_t_diaer, g__ltn_sm_i_hook_abv,
	g__ltn_sm_i_dot_blw, g__ltn_sm_dbl_barred_l, g__ltn_sm_t_diag_strk, g__ltn_sm_l_high_bar,
	g__ltn_sm_lum, g__ltn_sm_rum, g__ltn_sm_tum // lum, rum, tum??
	g__ltn_sm_insular_f, g__ltn_sm_l_trnd, g__ltn_sm_insular_s, g__ltn_sm_l_retr_hook_belt, g__ltn_sm_r_diag_strk);

c_narrowLowerDiac = (g__comb_lft_half_ring_blw, g__comb_up_tack_blw, g__comb_dwn_tack_blw, g__comb_dot_blw, g__comb_comma_blw, g__comb_cedilla, g__comb_ogonek, g__comb_vert_line_blw, g__comb_bridge_blw, g__comb_dbl_vert_line_blw);

/****
c_narrowMacron = (g_i,
	g_iacute, g_igrave, g_icircumflex, g_idieresis,
	g_i_s_ital, g0456, g2170, g_iacute_s_ital, g_igrave_s_ital, g0209,
	g0209_sItal, g_icircumflex_s_italic, g020b, g020b_sItal, g_ibreve, g_ibreve_s_ital,
	g01d0, g01d0_sItal, g_itilde, g_itilde_s_ital, g_imacron, g_imacron_s_ital,
	g_idieresis_s_ital, g0457, g1e2f, g1e2f_sItal, g_idotaccent, g_idotaccent_s_ital,
	g1ec9, g1ec9_sItal, g1e2d, g1e2d_sItal, g1ecb, g1ecb_sItal, g_iogonek,
	g_iogonek_retro_hook, g0268, g_i_dotless, g_dotlessi_s_ital,
	g_i_dotless_s_ital, g0456_dotless, g1d96_dotless, g0268_dotless, g1d09, g0269, g1d7c,

	g_l, g_l_s_ital, g217c, g2097, g2097_sItal, g02e1, g_lacute, g_lacute_s_ital, g_lcaron_caron, g1e3d,
	g1e3d_sItal, g1e3b, g1e3b_sItal, g1e37, g1e37_sItal, g1e39, g1e39_sItal, g_lcommaaccent,
	g_ldot, g_lcaron, g1d85, g1daa, g019a, ga749, g2c61, g026b, g_lslash, g026d, g1da9, g0234, g026c, ga78e, ga749_sItal,
	ga747, ga781,

	g_r, g_racute, g_rcaron, ga758, g1d514, g1d63, g1dca, g02b3, g036c, g_racute, g0211,
	g0213, g_rcaron, g1e59, g1e5f, g1e5b, g027d_lCStyle, g027c, g02b4, g027b, g02b5,

	g_t, g_tcaron_caron, g1e97, g1e6b, g1e71, g1e6f, g1e6d, g021b, g_tcaron, g0163, g01ab, g1db5,
	g_tbar, g1d75 );


#if (FONT == ANDIKAfont)

c_narrowMacron += (g0269_0301, g0269_0300, g0269_1dc7, g0269_0302, g0269_030c, g0269_0303, g0269_1dc6, g0269_0330,
	g_iogonek_tail_i_retro_hook, g0268_tailI, g0268_dotless_tailI, g_i_tail_i, g_dotlessi_tail_i,
	g_iacute_tail_i, g_igrave_tail_i, g0209_tailI, g_icircumflex_tail_i, g020b_tailI, g_ibreve_tail_i, g01d0_tailI,
	g_itilde_tail_i, g_imacron_tail_i, g1e2f_tailI, g_idieresis_tail_i, g1ec9_tailI, g1e2d_tailI, g1ecb_tailI,
	g_iogonek_tail_i,

	g_lcaron_caron_tail_l, g_l_tail_l, g_lacute_tail_l, g1e3d_tailL, g1e3b_tailL, g1e37_tailL, g1e39_tailL,
	g_lcommaaccent_tail_l, g_ldot_tail_l, g_lcaron_tail_l, g1d85_tailL, g1daa_tailL, g019a_tailL, g2c61_tailL,
	g026b_tailL, g_lslash_tail_l, g026c_tailL,

	g_tcaron_caron_no_tail_t, g0163_commaStyle_noTailT, g_t_no_tail_t, g1e97_noTailT, g1e6b_noTailT,
	g1e71_noTailT, g1e6f_noTailT, g1e6d_noTailT, g021b_noTailT, g_tcaron_no_tail_t, g0163_noTailT,
	g01ab_noTailT, g_tbar_no_tail_t, g1d75_noTailT, g2c66_noTailT);

#endif
****/

endtable; // glyph

// #include "pua.gdh"

#if (FONT == GENTIUMfont)
// Define the class of upper-case letters that need low-profile diacritics.
#include "takes_lowProfile.gdh"

table(glyph) {AttributeOverride = true}

cno_LP { lp_subclass = LP_BASEDIAC };
// The following glyphs have low-profile versions but do not have diacritics attached:
g__ltn_sm_i  { lp_subclass = LP_BASEONLY };
g__ltn_sm_j  { lp_subclass = LP_BASEONLY };
g__ltn_sm_lig_ij { lp_subclass = LP_BASEONLY };
// The following glyphs are just diacritics:
cUDia { lp_subclass = LP_DIACONLY };


// The following are lower-case glyphs with precomposed upper diacritics that have no low-profile equivalents.
// Any diacritics that stack on top of them should be low-profile.
c_lowerWnonLPdiacs = ( g__ltn_sm_a_ring_abv, g__ltn_sm_a_breve, g__ltn_sm_e_breve, g__ltn_sm_g_breve, g__ltn_sm_i_breve, g__ltn_sm_o_breve,
	g__ltn_sm_o_dbl_acute, g__ltn_sm_u_breve, g__ltn_sm_u_dbl_acute, g__ltn_sm_a_dbl_grave, g__ltn_sm_a_inv_breve, g__ltn_sm_e_dbl_grave, g__ltn_sm_e_inv_breve, g__ltn_sm_i_dbl_grave,
	g__ltn_sm_i_inv_breve, g__ltn_sm_o_dbl_grave, g__ltn_sm_o_inv_breve, g__ltn_sm_r_dbl_grave, g__ltn_sm_r_inv_breve, g__ltn_sm_u_dbl_grave, g__ltn_sm_u_inv_breve, g__ltn_sm_e_cedilla_breve, g__ltn_sm_w_ring_abv, g__ltn_sm_y_ring_abv, g__ltn_sm_a_rt_half_ring, g__ltn_sm_a_hook_abv,
	g__ltn_sm_a_breve_dot_blw, g__ltn_sm_e_hook_abv, g__ltn_sm_i_hook_abv, g__ltn_sm_o_hook_abv, g__ltn_sm_o_horn_hook_abv, g__ltn_sm_u_hook_abv, g__ltn_sm_u_horn_hook_abv, g__ltn_sm_y_hook_abv );

endtable;

#endif	// (FONT == GENTIUMfont)


//////////////////////////////////////////////////////////////////////////////////////
//
//	Features
//

#include "features.gdh"


//////////////////////////////////////////////////////////////////////////////////////
//
//	Rules
//

#if (FONT == GENTIUMfont)
// Combine any possible decomposed Greek into composed forms.
#include "greek_recompose.gdh"	// pass 1
#endif


table(substitution);

pass(1)  {MaxBackup = 15; MaxRuleLoop = 30}

// Decomposition/reordering
// Also Greek recomposition is done in pass 1 (in greek_recompose.gdh above).
// Also pitch processing (pitches.gdh).

/* --- removed feature ---
c_pua  >  c_noPua {pua = 1}  /  ^ _ ;
-------------------------- */

// Decompose possible vietnamese base + diac
c_baseCircum  _  >  c_base_noDiac:1  g__comb_circum:1  / ^ _ _;
c_baseBreve   _  >  c_base_noDiac:1  g__comb_breve:1  / ^ _ _;

// For the special bridging diacritic stuff, upper diacritics need to come first so they will attach
// to the first base (0311 and 0361 seem to be treated differently by NFD).
if (bridging_diac)
	cLDblDia  cUDblDia   >   @2  @1;
endif;


// Narrow macrons

if (!smallcaps)
g__comb_macron_blw  >  g__comb_macron_blw_short  /  c_narrowMacron  c_narrowLowerDiac? _ ;
endif;

endpass;  // sub - 1

#if (ANDIKAfamily)
if (smallcaps || (literacy == 0 && literacy__litr == 0))
#else
if (smallcaps || literacy || literacy__litr )
#endif

pass(2)

// Small-caps, literacy alternates

if (smallcaps)
	cno_sc  > c_sc;
endif;


// NB: Because 01E5 is affected by two features, barred_bowl and literacy,
// these features take special organization of their rules. Specifically,
// 01E5 should be displayed as:
//	if Literacy Alternates then LtnSmGBarredSngBowl (uni01E5.BarBowl.SngBowl)
//	else if Barred-Bowl Forms then LtnSmGBarredBowl (uni01E5.BarBowl)
//	else LtnSmGStrk (uni01E5)
// Note also that uni01E5 doesn't show up in any class.


// Note: literacy alternates take precedence over slant-italic feature (below).
// So we can ignore slant-italics here.
if (literacy == 1 || literacy__litr == 1)
	cno_SngBowl  > cSngBowl;		// (includes uni01E5.BarBowl > uni01E5.BarBowl.SngBowl)
	// g01e5_barBowl_sngBowl is conceptually equal to g01e5_sngBowl (since the forms are the same).
	// Don't add this correspondence to the SngBowl forms to avoid confusing the reverse rules below;
	// just use a separate rule:
	// g__ltn_sm_g_strk  >  g__ltn_sm_g_bar_bowl_sng_bowl;

	cno_SngStory > cSngStory;

else
	cSngBowl  > cno_SngBowl;		// (includes uni01E5.BarBowl.SngBowl > uni01E5.BarBowl)
	cSngStory > cno_SngStory;
endif;


endpass;  // sub - 2

#if (ANDIKAfamily)
endif; // pass constraint: if (small_caps || (literacy == 0 && literacy__litr == 0))
#else
endif; // pass constraint: if (small_caps || literacy || literacy__litr)
#endif

pass(3)  {MaxBackup = 15; MaxRuleLoop = 30}

// Many features: slant italic, Chinantec tones, ogoneks, cedillas, horns, Vietnamese, bridging diacritics,
// engs, ramshorn, mongolian E, short breve, barred bowls, strokes, open-o serif, v-hook, y-hook,
// ezh-curl, t-hook, b-hook, h-stroke, r-tail, p-hook, Romanian, ezh, apostrophe, modifier-low-colon,
// carons, ou, empty-set, cyrillic-shha, serbian, serif-beta, digit variations, Andika variations...
// Also pitch processing (in pitches.gdh).

// TODO: the code below will have to be extended somewhat to correctly handle the case where
// the slant-italic glyphs are the default.

if (slant_italic == 1 || slant_italic__ital)
	// ff, fi, fl ligatures
	g__ltn_sm_f  cfLigC2  >  g__ltn_sm_f_s_ital cfLigC2_sItal   / _ _ cDia;  // don't create a ligature, a following diac stops ligature from forming
	g__ltn_sm_f  cfLigC2  >  _ cfLig_sItal:(1 2) {component {f1.ref = @1; f2.ref = @2}};

	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  g__ltn_sm_f_s_ital  g__ltn_sm_f_s_ital  cffLigC3_sItal  / _ _ _ cDia;  // don't create a ligature
	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  _ _  cffLig_sItal:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}};

	cno_SItal  >  cSItal;		// f, i, l, v
	cno_2StorySItal  >  c2StorySItal;  // a, ae
else
	// ff, fi, fl ligatures
	g__ltn_sm_f  cfLigC2  >  @1 @2 / _ _ cDia; // do nothing, a following diac stops ligature from forming
	g__ltn_sm_f  cfLigC2  >  _ cfLig:(1 2) {component {f1.ref = @1; f2.ref = @2}}
		/  _ ^ _ ;	// back up to handle i-alternates

	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  @1 @2 @3 / _ _ _ cDia;  // do nothing
	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  _ _ cffLig:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}}
		/  _  _ ^ _;	// back up to handle i-alternates

	cSItal        >  cno_SItal;
	c2StorySItal  >  cno_2StorySItal;
endif;


// Turn combining half-marks into one double-width combining mark
g__comb_dbl_inv_breve_lft=d1  g__comb_dbl_inv_breve_rt=d2  >  g__comb_dbl_inv_breve:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;
g__comb_dbl_tilde_lft=d1  g__comb_dbl_tilde_rt=d2  >  g__comb_dbl_tilde:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;

// For Chinantec, make the standard Unicode characters look like the special PUA characters.
if (chinantec_tone == 1 || chinantec_tone__chtn == 1)
	cno_ChinantecTn  >  cChinantecTn;
else
	cChinantecTn  >  cno_ChinantecTn;
endif;

// Handle ogoneks; backup needed to also handle literacy feature:
cOgonekBase  g__comb_ogonek  >  cOgonekComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnODiaX)  _=d;

// Handle cedillas (including those that need to look like comma-accent by precomposing them);
// back-up needed to also handle rom feature:
cCedillaBase  g__comb_cedilla  >  cCedillaComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnHDiaX)  _=d;
// Handle horns:
cHornBase  g__comb_horn  >  cHornComposite$1:(b d)  _ {passKeySlot = true}  /  _=b  DIASTR4(cnRDiaX)  _=d;

// Handle Vietnamese
/* jw comments
     2 stacked diacs go to side-by-side unless there is an intervening upper diac.
     pre-composed base + stacked diacs go to pre-composed base+side-by-side (cVN) */
if (viet == 1 || viet__viet == 1)
	// decompose the stacked form and replace the base 'a' with the literacy form,
	// the diacritics with the Vietnamese form
	_  c_aStack_noLit  >  g__ltn_sm_a_sng_story:2  c_diacComb_vN / _ _ {literacy == 1 || literacy__litr == 1};

	c0302_noVN  cDiac_noVN  >  c_0302_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;
	c0306_noVN  cDiac_noVN  >  c_0306_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;

	cno_VN > cVN; // ie, when literacy == false
else
	cVN > cno_VN;
endif;

table(glyph)
cls_l_lower = (g__ltn_sm_l, g__ltn_sm_l_sc);	// include small caps
cls_o_lower = (g__ltn_sm_o, g__ltn_sm_o_sc);
cls_u_lower = (g__ltn_sm_u, g__ltn_sm_u_sc);
endtable;

if (bridging_diac)
	// LL with bridging diaeresis (U+035F is possible intervening bridging underbar)
	g__comb_diaer  >  g__comb_diaer_u_u  /  g__ltn_cap_l  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  g__ltn_cap_l;
	g__comb_diaer  >  g__comb_diaer_u_l  /  g__ltn_cap_l  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_l_lower;
	g__comb_diaer  >  g__comb_diaer_l_l  /  cls_l_lower  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_l_lower;

	// OU with bridging inverted breve (0311 / 0361)
	cno_BrInvBreve  >  cBrInvBreve_uU  /  g__ltn_cap_o  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  g__ltn_cap_u;
	cno_BrInvBreve  >  cBrInvBreve_uL  /  g__ltn_cap_o  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_u_lower;
	cno_BrInvBreve  >  cBrInvBreve_lL  /  cls_o_lower  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_u_lower;
endif;

#if DEBUG

if (debug == 1)
	g__qstn_mrk > g__digit_one		/ DeBuG g__space g__ltn_sm_e g__ltn_sm_n g__ltn_sm_g g__eq_sgn _ {eng == 0};
	g__qstn_mrk > g__digit_two		/ DeBuG g__space g__ltn_sm_e g__ltn_sm_n g__ltn_sm_g g__eq_sgn _ {eng == 1};
	g__qstn_mrk > g__digit_three	/ DeBuG g__space g__ltn_sm_e g__ltn_sm_n g__ltn_sm_g g__eq_sgn _ {eng == 2};
endif;

#endif  // DEBUG

/*
	NOTES:

	The rules are designed so that they work correctly no matter how the
	default value for a feature is set. While this means the rules don't
	demand that the cmap and feature table agree on the default glyph,
	the font will be more usable in non-GDL apps if they do agree.
	(One exception remaining is vietnamese processing -- so don't
	try to build a font with vietnamese on by default).

	If a glyph name extension (which is what drives the class names) is used
	within more than one feature (e.g., .LrgBowl is used in the Rams horn alternate
	and the Small ezh-curl alternate), then we cannot use the automatically generated
	class names (e.g., cLrgBowl and cno_LrgBowl), but rather must explicitly
	handle each glyph -- sigh.
*/

if (eng == descender && eng__Engs == descender)        // && because it is the default
	// for fonts with default = base, capital, or short:
	c_eng_BaselineHook  >  c_eng_Descender;
	c_eng_UCStyle       >  c_eng_Descender;
	c_eng_Kom           >  c_eng_Descender;
endif;
if (eng == base || eng__Engs == base)
	// for fonts with default = descender, capital, or short:
	c_eng_Descender   >  c_eng_BaselineHook;
	c_eng_UCStyle     >  c_eng_BaselineHook;
	c_eng_Kom         >  c_eng_BaselineHook;
endif;
if (eng == capital || eng__Engs == capital)
	// for fonts with default = descender, base, or short:
	c_eng_Descender    >  c_eng_UCStyle;
	c_eng_BaselineHook >  c_eng_UCStyle;
	c_eng_Kom          >  c_eng_UCStyle;
endif;
if (eng == short || eng__Engs == short)
	// for fonts with default = descender, capital, or base:
	c_eng_Descender    >  c_eng_Kom;
	c_eng_BaselineHook >  c_eng_Kom;
	c_eng_UCStyle      >  c_eng_Kom;
endif;

if (ramshorn == small && ramshorn__ramh)
	// for fonts with default = large or gamma
	(g__ltn_sm_rams_horn_lrg_bowl  g__ltn_sm_rams_horn_gamma_style) > g__ltn_sm_rams_horn;
endif;
if (ramshorn == large || ramshorn__ramh)
	// for fonts with default = small or gamma
	(g__ltn_sm_rams_horn 	g__ltn_sm_rams_horn_gamma_style)	> g__ltn_sm_rams_horn_lrg_bowl;
endif;
if (ramshorn == gamma || ramshorn__ramh == gamma)
	// for fonts with default = small or large
	(g__ltn_sm_rams_horn  g__ltn_sm_rams_horn_lrg_bowl)		> g__ltn_sm_rams_horn_gamma_style;
endif

// supernum feature dealt with in pitches.gdh

if (mongol_e == 1 || mongol_e__mone == 1)
	cno_MongolStyle > cMongolStyle;
else
	cMongolStyle >cno_MongolStyle;
endif;

#if 1 // FONT != DOULOSfont
/**** obsolete feature
if (cyr_curs_ital == 1)
	cno_Cursive  >  cCursive;
else
	cCursive  >  cno_Cursive;
endif;
****/
#endif // !DOULOSfont

if (short_breve == 1 || short_breve__sbrv)
	cno_CyShortMrkAlt > cCyShortMrkAlt;
else
	cCyShortMrkAlt > cno_CyShortMrkAlt;
endif;


// --- literacy and slant_italic features moved from here. ---


// The barred_bowl rule must happen *after* the literacy rule
if (barred_bowl == 1 || barred_bowl__bowl == 1)  //  does contain g01E5, no such naming as uni01e5 or
                                                 // uni anything. That is the Postscript Name from xml file.  jw 8/27/04
//	cno_BarBowl  >  cBarBowl;	// (does NOT include uni01E5 > uni01E5.BarBowl)
//	g01e5  >  g01e5_barBowl;		        yes it does jw.  commented 8/31
//					see: cno_BarBowl = (g0180, g_dcroat, g01e5);
	cno_barbowl > c_barbowl;
	g__ltn_sm_g_strk > g__ltn_sm_g_bar_bowl;
	g__ltn_sm_g_strk_sng_bowl > g__ltn_sm_g_bar_bowl_sng_bowl;
else
//	cBarBowl  >  cno_BarBowl;	// (does NOT include uni01E5.BarBowl > uni01E5)
//	g01e5_barBowl  >  g01e5;			yes it does jw
	c_barbowl > cno_barbowl;
	g__ltn_sm_g_bar_bowl > g__ltn_sm_g_strk;
	g__ltn_sm_g_bar_bowl_sng_bowl > g__ltn_sm_g_strk_sng_bowl;
endif;

if (ltnjstroke == doubleSerif || ltnjstroke__Jstk == doubleSerif)
	cno_DblSerif  >  cDblSerif;
else
	cDblSerif  >  cno_DblSerif;
endif;

if (open_o == topSerif || open_o__opnO == topSerif)
	cno_TopSerif  >  cTopSerif;
else
	cTopSerif  >  cno_TopSerif;
endif;

if (v_hook == curved && v_hook__v_hk == curved)  // && becaue it is the default
	c_vhook_StraightLeft >  c_vhook_Curved;
	c_vhook_HighHook     >  c_vhook_Curved;
endif;
if (v_hook == straightLeft || v_hook__v_hk == straightLeft)
	c_vhook_Curved    >  c_vhook_StraightLeft;
	c_vhook_HighHook  >  c_vhook_StraightLeft;
endif;
if (v_hook == highHook || v_hook__v_hk == highHook)
	c_vhook_Curved       >  c_vhook_HighHook;
	c_vhook_StraightLeft >  c_vhook_HighHook;
endif;

if (y_hook == 1 || y_hook__Y_hk == 1)
	cno_RtHookYhook  >  cRtHookYhook;
else
	cRtHookYhook  >  cno_RtHookYhook;
endif;

if (n_hook == 1 || n_hook__N_hk == 1 )
	cno_LCStyleNhook  >  cLCStyleNhook;
else
	cLCStyleNhook  >  cno_LCStyleNhook;
endif;

if (ezh_curl == 1 || ezh_curl__ezhc == 1)
	g__ltn_sm_ezh_curl  >  g__ltn_sm_ezh_curl_lrg_bowl;
else
	g__ltn_sm_ezh_curl_lrg_bowl  >  g__ltn_sm_ezh_curl;
endif;

if (t_hook == 1 || t_hook__t_hk == 1)
	cno_RtHookThook  >  cRtHookThook;
else
	cRtHookThook  >  cno_RtHookThook;
endif;

if (b_hook == 1 || b_hook__B_hk == 1)
	cno_TopBarB  >  cTopBarB;
else
	cTopBarB  >  cno_TopBarB;
endif;

if (d_hook == 1 || d_hook__D_hk == 1)
	cno_TopBarD  >  cTopBarD;
else
	cTopBarD  >  cno_TopBarD;
endif;

if (h_stroke == 1 || h_stroke__Hstk == 1)
	cno_VertStrk  >  cVertStrk;
	////cno_BarStem  >  cBarStem;
else
	cVertStrk  >  cno_VertStrk;
	////cBarStem  >  cno_BarStem;
endif;

if (r_tail == 1 || r_tail__R_tl == 1)
	cno_LCStyleRtail  >  cLCStyleRtail;
else
	cLCStyleRtail  >  cno_LCStyleRtail;
endif;

if (p_hook == 1 || p_hook__p_hk == 1)
	cno_BowlHook  >  cBowlHook;
else
	cBowlHook  >  cno_BowlHook;
endif;

/* --- removed feature ---
if (rom == 1)
	cno_CommaStyle  >  cCommaStyle;
else
	cCommaStyle  >  cno_CommaStyle;
endif;
-------------------------- */

if (ezh == 1 || ezh__Ezhr == 1)
	cno_RevSigmaStyle  >  cRevSigmaStyle;
else
	cRevSigmaStyle  >  cno_RevSigmaStyle;
endif;

// ogonek processing must be in pass 2

if (apostrophe == 1 || apostrophe__apos == 1)
	cno_Lrg  >  cLrg;
else
	cLrg  >  cno_Lrg;
endif;

if (modlowcolon == wide || modlowcolon__coln == wide)
  cno_Wide >  cWide;	// a789, was gf1e9
  //gf1e9  >  gf1e9_wide;
else
  cWide  >  cno_Wide;
  //gf1e9_wide  >  gf1e9;
endif;

if (caron == 0 && caron__carn == 0)  // && because it is the default
	// European caron combinations (feature OFF)
	//if (select_diac)
	//	cno_CaronEuro  g030c  >  _  cCaronEuro$1:(1 2) {comp {base.ref = @1; caron.ref = @2}; passKeySlot=1};
	//else
		cno_CaronEuro  g__comb_caron  >  _  cCaronEuro$1:(1 2) {passKeySlot=1};
	//endif;
endif;
if (caron == 1 || caron__carn == 1)
	// Non-European caron but NFC: decompose and use standard caron
	cCaronEuro  _  >  cno_CaronEuro:1  g__comb_caron:1;
endif;

if (ou == 1 || ou__opOU == 1)
	cno_OpenTop  >  cOpenTop;
else
	cOpenTop  >  cno_OpenTop;
endif;

if (emptyset == 1 || emptyset__empt)
	cno_SlashZero  >  cSlashZero;
else
	cSlashZero  >  cno_SlashZero;
endif;

/* --- Obsolete feature ---
if (ltnglottalstop == capHeight)
  g0294_lC  >  g0294;
else
  g0294  >  g0294_lC;
endif;
--------------------------- */

if (cyrillic_shha == 1 || cyrillic_shha__shha == 1)
	cno_UCStyleCyrShha  >  cUCStyleCyrShha;
else
	cUCStyleCyrShha  >  cno_UCStyleCyrShha;
endif;

if (serbian == 1 || serbian__locl == 1)
	cno_Serb  >  cSerb;
else
	cSerb  >  cno_Serb;
endif;

#if (FONT == GENTIUMfont)

if (serif_beta == 1 || serif_beta__beta == 1)
	cno_Serif  >  cSerif;
else
	cSerif  >  cno_Serif;
endif;

if (greek_circ == 1 || greek_circ__pcir == 1)
	cno_Por  >  cPor;
else
	cPor  >  cno_Por;
endif;

#endif // GENTIUMfont


#if (ANDIKAfamily)

if (zero == 1 || zero__dig0 == 1)
	cno_Slash  >  cSlash;
else
	cSlash  >  cno_Slash;
endif;

if (one == 1 || one__dig1 == 1)
	cno_NoBase  >  cNoBase;
else
	cNoBase  >  cno_NoBase;
endif;

if (four == 1 || four__dig4 == 1)
	cno_Open  >  cOpen;
else
	cOpen  >  cno_Open;
endif;

if (six_nine == 1 || six_nine__dg69 == 1)
	cno_Diag  > cDiag;
else
	cDiag  >  cno_Diag;
endif;

if (seven == 1 || seven__dig7 == 1)
	cno_Bar  >  cBar;
else
	cBar  >  cno_Bar;
endif;

if (i_hook == 1 || i_hook__i_tl == 1)
	cno_TailI  >  cTailI;
else
	cTailI  >  cno_TailI;
endif;

if (j_serif == 1 || j_serif__jser == 1)
	cno_TopLftSerif  >  cTopLftSerif;
else
	cTopLftSerif  >  cno_TopLftSerif;
endif;

// No-Tail-T, Tail-L - see below

if (q_diagtail == 1 || q_diagtail__Qalt == 1)
	cno_DiagTail  >  cDiagTail;
else
	cDiagTail  >  cno_DiagTail;
endif;

if (q_point == 1 || q_point__q_tl)
	cno_Point  >  cPoint;
else
	cPoint  >  cno_Point;
endif;


if (y_tail == 1 || y_tail__y_tl == 1)
	cno_NoTailY  > cNoTailY;
else
	cNoTailY  >  cno_NoTailY;
endif;

#endif	// ANDIKAfamily

endpass;  // sub - 3


pass(4)  {MaxBackup = 15; MaxRuleLoop = 30}	// substitution

// Low-profile diacritics, more Andika features, dotless i + diac, ogonek, superscript/subscript diac,...


#if (FONT == GENTIUMfont)

// Low-profile diacritics--do this after processing Vietnamese.

// All stacking diacritics should be low-profile.
// In each of these rules we back up to handle dotless stuff.

// Mark the upper diacritic as needing low-profile because it is in a stack:
cno_LP  cUDia  >  cLP  @U {needs_lp = 1}  / ^ _ {lp_subclass == LP_DIACONLY}  DIASTR4(cnUDiaX)  _=U;
cno_LP  >  cLP  /  ^ _ {needs_lp == 1};  // needs LP because it follows an LP-diac from rule above
cno_LP  >  cLP  /  cUDia ^ _ {lp_subclass == LP_DIACONLY};
cno_LP  >  cLP  / c_lowerWnonLPdiacs ^ _;	// eg, NFC e-breve+circumflex, w-ring+acute

// Make sure to use low-profile diacritics on any decomposed uppercase.
cno_LP  >  cLP  /  cTakesLPDiac  DIASTR4(cnUDiaX) ^ _ {lp_subclass == LP_DIACONLY} ;

// Don't try to do low-profile stuff with small-caps.
if ((low_profile_diac || low_profile_diac__lopr) && !smallcaps)
	cno_LP  >  cLP  / ^ _;	// back up to handle dotless stuff
endif;

#endif // GENTIUMfont


#if (ANDIKAfamily)

// Andika features that interact with other features

if (t_tail == 1 || t_tail__t_tl == 1)
	cno_NoTailT  >  cNoTailT;
else
	cNoTailT  >  cno_NoTailT;
endif;

if (l_hook == 1 | l_hook__l_tl == 1)
	cno_TailL  >  cTailL;
else
	cTailL  >  cno_TailL;
endif;

#endif // ANDIKAfamily


// Convert i to dotless i when followed by upper diacritic.

// decomposed sequences:
cno_Dotless  cUDia=D  >  cDotless  @D {passKeySlot=1}  /  _  ^  DIASTR4(cnUDiaX)  _=D;
// precomposed chars with i are done by decomposition:
cSpecialDotted  _  cUDia=D  >  g__ltn_sm_i_dotless  cSpecialDottedDia$1:1  @D {passKeySlot=1}
	/  _  _  ^  DIASTR4(cnUDiaX)  _=D;

// Now that ogonek has been composed with its vowels, do retrohook style if wanted:

if (ogonek == americanist || ogonek__ogon == americanist)
	cno_RetroHook > cRetroHook;
else
	cRetroHook > cno_RetroHook;
endif;

//	g__aogonek	> g__a g0328_retroHook:1;
//	g_aogonek	> g_a  g0328_retroHook:1;
//	g__eogonek	> g__e g0328_retroHook:1;
//	g_eogonek	> g_e  g0328_retroHook:1;
//	g__iogonek	> g__i g0328_retroHook:1;
//	g_iogonek_dotless > g_i_dotless g0328_retroHook:1;
//	g_iogonek	> g_i  g0328_retroHook:1;
//	g__uogonek	> g__u g0328_retroHook:1;
//	g_uogonek	> g_u  g0328_retroHook:1;
//	g01ea		> g__o g0328_retroHook:1;
//	g01eb		> g_o  g0328_retroHook:1;
//	g01ec		> g__omacron g0328_retroHook:1;
//	g01ed		> g_omacron  g0328_retroHook:1;
//	g_ogonek	> g_ogonek_retro_hook:1;
//	g0328		> g0328_retroHook:1;
//endif;


// Handle superscript/subscript diacritics; currently the only one of interest is a diaeresis:
cno_Sup  >  cSup  /  (cModSuper cModSub)  _;


/* --- removed feature ---
// Deprecated PUA

if (dep_pua == unicode51)
	cno_Dep51  >  cDep51  /  _ {pua==1};
endif;
if (dep_pua == unicode50)
	cno_Dep50  >  cDep50  /  _ {pua==1};
endif;
if (dep_pua == unicode41)
	cno_Dep41  >  cDep41  /  _ {pua==1};
endif;
if (dep_pua == unicode40)
	cno_Dep40  >  cDep40  /  _ {pua==1};
endif;
-------------------------- */


endpass;  // sub - 4


endtable; // substitution


#include "pitches.gdh"


table(positioning) {MUnits = 1000};

// Handle attachments

pass(1)

#define pos_rule(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}
#define pos_ruleSD(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; insert = 1; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}


//if (select_diac)
//	pos_ruleSD(cTakesHDia, cHDia, HS, HM, cnHDiaX);
//	pos_ruleSD(cTakesLDia, cLDia, LS, LM, cnLDiaX);
//	pos_ruleSD(cTakesODia, cODia, OS, OM, cnODiaX);
//	pos_ruleSD(cTakesRDia, cRDia, RS, RM, cnRDiaX);
//	pos_ruleSD(cTakesUDia, cUDia, US, UM, cnUDiaX);
//else
	pos_rule(cTakesHDia, cHDia, HS, HM, cnHDiaX);
	pos_rule(cTakesLDia, cLDia, LS, LM, cnLDiaX);
	pos_rule(cTakesODia, cODia, OS, OM, cnODiaX);
	pos_rule(cTakesRDia, cRDia, RS, RM, cnRDiaX);
	pos_rule(cTakesUDia, cUDia, US, UM, cnUDiaX);
//endif;


// Bridge diacritics handled by attachment need to have zero advance width,
// otherwise they push the second character out and away. (This wouldn't work if above
// we didn't reprocess attached diacritics using the ^ mechanism.)
cBridgeDiac {advance.x = 0};

endpass; // pos - 1


// Handle double-diacritics

pass(2)	// positioning

	// Double-diacritics above: the ".1" gives the bounding box of the attached cluster of
	// base + diacritics.

	// Something on both sides:
	cUDblDia {shift.y = max(@B.boundingbox.top.1, @A.boundingbox.top.1) - @D.boundingbox.bottom + 100m ;
			shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
			/ cTakesUDia=B  DIASTR3(cDia)  cLDblDia?  _=D  DIASTR3(cDia)  cTakesUDia=A;
	// Beginning of line:
	cUDblDia {shift.y = @B.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ cTakesUDia=B  DIASTR5(cDia)  cLDblDia?  _=D;
	// End of line:
	cUDblDia {shift.y = @A.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ DIASTR5(cDia)  cLDblDia?  _=D  cTakesUDia=A;

endpass; // pos - 2


pass(3)

	// Double-diacritics below:

	// Special case for two bridging diacritics:
	g__comb_dbl_macron_blw {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ;
		  shift.x = (@A.boundingbox.width - @B.boundingbox.width)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ;
		  shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = @B.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ cTakesLDia=B  DIASTR5(cDia)  cUDblDia?  _=D ;
	cLDblDia {shift.y = @A.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ DIASTR5(cDia)  cUDblDia?  _=D  cTakesLDia=A ;


endpass; // pos - 3

////#include "kern.gdh"

endtable; // positioning
