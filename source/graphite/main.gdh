/*
    Title:   Roman Font GDL description
    Authors: Martin Hosken, Bob Halllissy, Joan Wardell, Sharon Correll


	This file is part of Gentium Plus font family 
	(http://scripts.sil.org/Gentium) and is 
	Copyright (c) 2003-2014 SIL International (http://www.sil.org/),
	with Reserved Font Names "Gentium" and "SIL".

	This Font Software is licensed under the SIL Open Font License,
	Version 1.1.

	You should have received a copy of the license along with this Font Software.
	If this is not the case, go to (http://scripts.sil.org/OFL) for all the
	details including a FAQ.


    Changes:
AKW 2013-Mar-05  Remove Deprecated PUA feature
SJC 2008-Oct     More changes for ditto
SJC 2008-Aug-26  Various changes for small-caps, deprecated PUA, etc.
SJC 2008-Apr-23  Changed Tat alternates back to H-stroke alternates
SJC 2008-Apr-15  Patch (kludge) to handle dotless i w/ alternate tail
AKW 2008-Apr-02  Restore hookabove glyphs to Vietnamese diacritic classes
SJC 2007-Oct-31  Added #ifs for Gentium Basic and Gentium Book Basic
SJC 2007-Jan-26  Cleaned up distinction between Open-O alternates and J-stroke-hook-alternate
SJC 2006-Dec-4   Various changes for new version to support Unicode 5.0:
	Changed VNStyle to vN; added Chinantec tones, Cyrillic cursive italics, open-o serif feature
SJC 2006 ??????  Added barred-j modifier to take smaller diacritics; added smallcaps code (turned off)
SJC 2006-Apr-6   Allow ogonek and literacy rules to both fire
SJC 2006-Mar-21  Handle literacy alternates + Vietnamese diacritics for NFC data
SJC 2006-Jan-23  Added Cyrillic shha alternate
SJC 2005-Oct-14  Added slant-italic ff, fi, fl ligatures
SJC 2005-Oct-13  Made ff, fi, fl true ligatures with components.
SJC 2005-Oct-12  Fixed problems with dotted modifier super/subscripts and partial fix for F17A (double diaeresis).
SJC 2005-Sep-1   Added slant-italic special forms, diaersis on superscripts, and bridging diacritics.
SJC 2005-May-16  Handle features modlowcolon, ltnglottalstop, and ltnjstroke.
SJC 2005-May-16  Turn off AutoPseudo.
SJC 2005-May-10  Added a few comments.
AKW 2005-May-09  Changed gF176 to g035C (PUA character accepted into Unicode).
JMW 2004-Sep-02  For now, I will take easy option on fixing Literacy Alts and Romanian,
    by backing up. Later I may re-write. Input to WP2 is now NFD, necessitating a change.
JMW 2004-Jul-21  Comments on Viet, add 4th Eng.
RMH 2004-Mar-17  Changed logic for ou alternates due to default is now closed top,
	and alternate is .OpenType  (issue RFS-5WXH4D);
	added omacron and Omacron to things that can composite with ogonek (related to issue RFS-5X5FKC);
	renamed cnDia to cDia -- it is a class of all diacritics, not the class of non-diacritics;
	added cHDia to cBDia, but I think the cBDia and cnBDia classes aren't used...?
RMH 2004-Feb-25  removed all smartcode that builds alternates (of composites) by decomposition
	(we now have real alternates available in the font);
	in the process, eliminated viet.gdh -- integrating it directly here.
RMH 2004-Feb-13  Made explicit associations to quiet new GrCompiler warnings.
RMH 2004-Feb-05  Rewrote rules that had been generated by normal_rules() function in makegdl.pl so
	that (1) only those glyphs that need composition (things with ogonek, cedilla, horn)
	are actually composed, and (2) now permits other diacritcs to intervene.
	Similarly added code to permit intevening diacs in rules for .vNStyle diac ligatures.
RMH 2004-Feb-04 Changes after B14: implemented logic for retrohookstyle ogonek alternates feature.
RMH 2004-Jan-19 Changes after B10: omehow p_hook feature wasn't ever implemented.
RMH 10-Oct-2003 Significant rework:
	added "else" clauses for most features (so this same code works if
	Feature table and cmap are changed so an "alternate" glyph is the default);
	added code to handle cedillas that need to be rendered as commaaccent;
	added DeBuG feature (only compiled in if symbol DEBUG is defined as non-zero).
RMH 01-Sep-2003 Reworked all features per PC's design.
RMH 15-Aug-2003  Added other Unicode 4.0 double-diacritics;
    fixed double diacritic positioning so not dependent on glyph's default location
	(requires double diacritics should NOT have attachment points).
RMH 17-Jul-2003  Removed all references to "P" and "_P" attachment points -- it no longer exists;
    replace refs to U+F177 with U+035E (Unicode 4.0).
RMH 10-Jul-2003  Added logic to decompose 1E2D and 1ECB in the context of upper diacritics.
MJPH 16-Nov-2002 Move overarch to down by -1200m from -700m.
*/

#include "stddef.gdh"

#define CHARISfont 1
#define DOULOSfont 2
#define GENTIUMBASICfont 3
#define GENTIUMBOOKBASICfont 4
#define GENTIUMfont 5
#define GENTIUMBOOKfont 6
#define ANDIKABASICfont 7
#define ANDIKAfont 8

/////#define GENBASICfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont)
#define BASIC (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == ANDIKABASICfont)
#define ANDIKAfamily (FONT == ANDIKAfont || FONT == ANDIKABASICfont)
#define GENTIUMfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == GENTIUMfont || FONT == GENTIUMBOOKfont)

// Now turn on the font we want, so we get specific features. (This file is copied from
// something like doulos.gdh or charis.gdh by the build process.)
#include "fontSpecific.gdh"

#define DEBUG 0
// #define DEBUG 1  //jw 7/21/04 Use this to turn on DEBUG

#define SMALLCAPS 0

Bidi = 0;

// We handle double-encoded glyphs by hand, for the deprecated-PUA feature.
AutoPseudo = 0;

#define DIASTR3(x) [ x [ x x?]?]?
#define DIASTR4(x) [ x [ x [ x x?]?]?]?
#define DIASTR5(x) [ x [ x [ x [ x x?]?]?]?]?
#define attached	user1

// user1 - user4 are used in pitches.gdh
// user1 is used by both pitch and attachment stuff because there should not be any conflict.
// user2 is used by both pitch and low-profile stuff because there should not be any conflict.

#define needs_lp	user2

// #define pua		user5

#define LP_DIACONLY 0
#define LP_BASEONLY 1
#define LP_BASEDIAC 2

////#define KERNPASS 3

#if DEBUG
#define DeBuG g__d g_e g__b g_u g__g g_colon 
#endif

//////////////////////////////////////////////////////////////////////////////////////
//
//	Glyphs
//

table(glyph);

// To make upstream whitespace be reordered at the end of a line; shouldn't be
// needed if compiler is working correctly.
//clsSpaces = (g_space, g2000, g2001, g2002, g2003, g2004, g2005
//				g2006, g2007, g2008, g2009, g200A, g200B)
//			{ dir = DIR_WHITESPACE };


// Additions to feature classes for small caps; these are not included
// automatically by make_gdl.

cBaselineHook += (g_eng_baseline_hook_sc); // but these classes aren't really used
cUCStyle += (g_eng_u_c_style_sc);
cKom += (g_eng_kom_sc);
cno_BaselineHook += (g_eng_sc);
cno_UCStyle += (g_eng_sc);
cno_Kom += (g_eng_sc);

// This class is not useful since there are two different features that use "topBar":
//cTopBar += (g0253_topBar_sc);
//cno_TopBar += (g0253_sc);

cTopBarB = (g0253_topBar, g0181_topBar, g0253_topBar_sc);
cno_TopBarB = (g0253, g0181, g0253_sc);

cTopBarD = (g018a_topBar, g0257_topBar_sc);
cno_TopBarD = (g018a, g0257_sc);

cVertStrk += (g_hbar_vert_strk_sc);
cno_VertStrk += (g_hbar_sc);

//cCommaStyle += (g_scedilla_comma_style_sc, g0163_commaStyle_sc);
//cno_CommaStyle += (g_scedilla_sc, g0163_sc);

cTopSerif += (g0254_topSerif_sc);
cno_TopSerif += (g0254_sc);

cLCStyleNhook = (g019d_lCStyle, g0272_lCStyle_sc);
cno_LCStyleNhook = (g019d, g0272_sc);

cLCStyleRtail = (g2c64_lCStyle, g027d_lCStyle_sc); // what about lowercase r-tail SC?
cno_LCStyleRtail = (g2c64, g027d_sc);

cRtHookThook = (g01ac_rtHook, g01ad_rtHook_sc);
cno_RtHookThook = (g01ac, g01ad_sc);

cRtHookYhook = (g01b3_rtHook, g01b4_rtHook_sc);
cno_RtHookYhook = (g01b3, g01b4_sc);

cStraightLft += (g028b_straightLft_sc);
cStraightLftHighHook += (g028b_straightLftHighHook_sc);
cno_StraightLft += (g028b_sc);
cno_StraightLftHighHook += (g028b_sc);

cRevSigmaStyle += (g04e1_revSigmaStyle_sc, g0292_revSigmaStyle_sc);
cno_RevSigmaStyle += (g04e1_sc, g0292_sc);

cOpenTop += (g0223_openTop_sc);
cno_OpenTop += (g0223_sc);

cMongolStyle += (g044d_mongolStyle_sc);
cno_MongolStyle += (g044d_sc);

cLrg += (ga78c_lrg_sc);
cno_Lrg += (ga78c_sc);

cRetroHook += (
		g_aogonek_retro_hook_sc,	g_aogonek_sng_story_retro_hook_sc,	g_eogonek_retro_hook_sc,
		g_iogonek_retro_hook_sc,	g_uogonek_retro_hook_sc, 			g01eb_retroHook_sc,			g01ed_retroHook_sc);
cno_RetroHook += (
		g_aogonek_sc,					g_aogonek_sng_story_sc,			g_eogonek_sc,
		g_iogonek_sc,					g_uogonek_sc,					g01eb_sc,					g01ed_sc);
				


cVN += (g1ea5_vN_sc,	g1ea7_vN_sc,	g1eab_vN_sc,	g1ea9_vN_sc,
		g1eaf_vN_sc,	g1eb1_vN_sc,	g1eb5_vN_sc,	g1eb3_vN_sc,
		g1ea5_sngStory_vN_sc,	g1ea7_sngStory_vN_sc,	g1eab_sngStory_vN_sc,	g1ea9_sngStory_vN_sc,
		g1eaf_sngStory_vN_sc,	g1eb1_sngStory_vN_sc,	g1eb5_sngStory_vN_sc,	g1eb3_sngStory_vN_sc,
		g1ebf_vN_sc,	g1ec1_vN_sc,	g1ec5_vN_sc,	g1ec3_vN_sc,	g1ed1_vN_sc,	g1ed3_vN_sc,	g1ed7_vN_sc,	g1ed5_vN_sc);
		
cno_VN += (g1ea5_sc,	g1ea7_sc,		g1eab_sc,		g1ea9_sc,
		g1eaf_sc,		g1eb1_sc,		g1eb5_sc,		g1eb3_sc,
		g1ea5_sngStory_sc,		g1ea7_sngStory_sc,		g1eab_sngStory_sc,		g1ea9_sngStory_sc,
		g1eaf_sngStory_sc,		g1eb1_sngStory_sc,		g1eb5_sngStory_sc,		g1eb3_sngStory_sc,
		g1ebf_sc,		g1ec1_sc,		g1ec5_sc,		g1ec3_sc,		g1ed1_sc,		g1ed3_sc,		g1ed7_sc,		g1ed5_sc);


// Why is there no g_lcaron_caron_sc??

// Give a better name:
c_sc = csc;


// Classes of double-diacritics above and below:
cUDblDia = (g035d  g035e  g0360  g0361  gf17a	g1dcd);
cLDblDia = (g035f  g0362  g035c);


// Various classes of diacritics; the classes generated by make_gdl are not helpful.
cBDia = (cLDia cODia cHDia);				// Below = Lower + Ogonek + Cedilla
cnBDiaX = (cUDia cRDia);					// Not Below
cnHDiaX = (cLDia cODia cRDia cUDia);		// Not Cedilla
cnLDiaX = (cHDia cODia cRDia cUDia);		// Not Lower
cnODiaX = (cHDia cLDia cRDia cUDia);		// Not Ogonek
cnRDiaX = (cHDia cLDia cODia cUDia);		// Not Horn (right)
cnUDiaX = (cHDia cLDia cODia cRDia );		// Not Upper
cDia =  (cHDia cLDia cODia cRDia cUDia);	// Any (but not double dias)

// ff, fi, fl ligatures

cfLigC2 = (g_f  g_i  g_l);
cfLig  = (g_f_f  g_f_i  g_f_l);
cffLigC3 = (g_i  g_l);
cffLig = (g_f_f_i  g_f_f_l);

cfLigC2_sItal  = (g_f_s_ital, g_i_s_ital, g_l_s_ital);
cfLig_sItal    = (g_f_f_s_ital, g_f_i_s_ital, g_f_l_s_ital);
cffLigC3_sItal = (g_i_s_ital, g_l_s_ital);
cffLig_sItal   = (g_f_f_i_s_ital, g_f_f_l_s_ital);

cfLig_all = (cfLig  cfLig_sItal)
	{ component {f1 = box(0, -descent, aw/2, ascent); f2 = box(aw/2, -descent, aw, ascent) }};
cffLig_all = (cffLig  cffLig_sItal)
	{ component { f1 = box(0, -descent, aw/3, ascent);
					f2 = box(aw/3, -descent, (2*aw)/3, ascent);
					f3 = box((2*aw)/3, -descent, aw, ascent) }}

cSpecialDotted = (g1e2d  g1ecb);		// i with lower diacritics
cSpecialDottedDia = (g0330  g_dotbelowcomb);


// Special class defs for cedilla compositions that are rendered as commaaccent:
cCedillaBase = (g__g  g_g  g__k  g_k  g__l  g_l  g__n  g_n  g__r  g_r);
cCedillaComposite = (g__gcommaaccent g_gcommaaccent g__kcommaaccent g_kcommaaccent
		g__lcommaaccent	g_lcommaaccent g__ncommaaccent g_ncommaaccent g__rcommaaccent
		g_rcommaaccent);

// Add in other cedilla composites:
cCedillaBase += (g__c  g_c  g__s  g_s  g__t  g_t  g__e  g_e  g_s_sc  g_t_sc)
cCedillaComposite += (g__ccedilla g_ccedilla g__scedilla g_scedilla
		g0162  g0163  g0228  g0229  g_scedilla_sc  g0163_sc)

// Ogonek composites:
cOgonekBase = (g__a  g_a  g__e  g_e  g__u  g_u  g__o  g_o  g__omacron  g_omacron);
cOgonekComposite = (g__aogonek g_aogonek g__eogonek g_eogonek g__uogonek
		g_uogonek  g01ea  g01eb  g01ec  g01ed);

// Horn composites:
cHornBase = (g__o  g_o  g__u  g_u);
cHornComposite = (g__ohorn  g_ohorn  g__uhorn  g_uhorn);

// Modifier superscripts that require smaller diacritics:
cModSuper = (g02b0  g02b1  g02b2  g02b3  g02b4  g02b5  g02b6  g02b7  g02b8
		g02c0  g02c1  g02e0  g02e1  g02e2  g02e3  g02e4
		g1d2c  g1d2d  g1d2e  g1d2f
		g1d30  g1d31  g1d32  g1d33  g1d34  g1d35  g1d36  g1d37
		g1d38  g1d39  g1d3a  g1d3b  g1d3c  g1d3d  g1d3e  g1d3f
		g1d40  g1d41  g1d42  g1d43  g1d44  g1d45  g1d46  g1d47
		g1d48  g1d49  g1d4a  g1d4b  g1d4c  g1d4d  g1d4e  g1d4f
		g1d50  g1d51  g1d52  g1d53  g1d54  g1d55  g1d56  g1d57
		g1d58  g1d59  g1d5a  g1d5b  g1d5c  g1d5d  g1d5e  g1d5f  g1d60  g1d61  g1d78
		g1d9b  g1d9c  g1d9d  g1d9e  g1d9f
		g1da0  g1da1  g1da2  g1da3  g1da4  g1da5  g1da6  g1da7
		g1da8  g1da9  g1daa  g1dab  g1dac  g1dad  g1dae  g1daf
		g1db0  g1db1  g1db2  g1db3  g1db4  g1db5  g1db6  g1db7
		g1db8  g1db9  g1dba  g1dbb  g1dbc  g1dbd  g1dbe  g1dbf  g2071  g207f
		g2071_dotless  g02b2_dotless  g1da4_dotless  g1da8_dotless);
		
// Modifier subscripts that require smaller diacritics:
cModSub = (g1d62  g1d63  g1d64  g1d65  g1d66  g1d67  g1d68  g1d69  g1d6a
		g2090  g2091  g2092  g2093  g2094
		g1d62_dotless);

// Vietnamese diacritic combinations

#if (FONT == GENTIUMfont)
c0302_noVN = (g0302  g0302_lP);
#else
c0302_noVN = (g0302);
#endif

c0306_noVN = (g0306);
					
cDiac_noVN = (g_acutecomb		g_gravecomb		g_hookabovecomb 	g_tildecomb);
c_0302_DiacVN = (	g0302_acutecomb_vN		g0302_gravecomb_vN
					g0302_hookabovecomb_vN	g0302_tildecomb_vN);
c_0306_DiacVN = (	g0306_acutecomb_vN		g0306_gravecomb_vN
					g0306_hookabovecomb_vN	g0306_tildecomb_vN);

#if (FONT == GENTIUMfont)
cno_LP += (	g0302_acutecomb_vN		g0302_gravecomb_vN		g0302_tildecomb_vN		g0302_hookabovecomb_vN
			g0306_acutecomb_vN		g0306_gravecomb_vN		g0306_tildecomb_vN );
cLP += 	(	g0302_acutecomb_vNLP	g0302_gravecomb_vNLP	g0302_tildecomb_vNLP	g0302_hookabovecomb_vNLP
			g0306_acutecomb_vNLP	g0306_gravecomb_vNLP	g0306_tildecomb_vNLP );
#endif

// Precomposed base + first diac
c_baseCircum = (g__acircumflex, g_acircumflex, g__ecircumflex, g_ecircumflex, 
				g__icircumflex, g_icircumflex, g__ocircumflex, g_ocircumflex, 
				g__ucircumflex, g_ucircumflex);
c_baseBreve  = (g__abreve, g_abreve, g__ebreve, g_ebreve, 
				g__ibreve, g_ibreve, g__obreve, g_obreve, g__ubreve, g_ubreve);
c_base_noDiac = (g__a, g_a, g__e, g_e, g__i, g_i, g__o, g_o, g__u, g_u);

// Vietnamese/literacy combinations

// a with stacked diacritics
c_aStack_noLit = (g1ea5  g1ea7  g1ea9  g1eab  g1eaf  g1eb1  g1eb5  g1eb3); // eg, a+circum+acute
c_diacComb_vN = (g0302_acutecomb_vN, g0302_gravecomb_vN,
			g0302_hookabovecomb_vN, g0302_tildecomb_vN, 
			g0306_acutecomb_vN, g0306_gravecomb_vN,
			g0306_hookabovecomb_vN, g0306_tildecomb_vN);


// These caron combinations are treated specially by European languages, which is the default:
cCaronEuro = (g_dcaron, g_lcaron, g__lcaron, g_lcaron_sc, g_tcaron);
cno_CaronEuro = (g_d, g_l, g__l, g_l_sc, g_t);

// These work for Doulos:
g_dcaron {comp {base = box(0, bb.bottom-50m, (3*aw)/4, bb.top+50m);
                caron = box((3*aw)/4, bb.top - 450m, aw,bb.top+50m) }};
                 
g_lcaron {comp {base = box(0,bb.bottom-70m, (2*aw)/3, bb.top+50m);
                caron = box((5*aw)/8, bb.top - 450m, aw,bb.top+50m) }};
                 
g__lcaron {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-200m,bb.top+50m) }};
                 
g_lcaron_sc {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-100m,bb.top+50m) }};

g_tcaron {comp {base = box(0,bb.bottom-50m, bb.right-200m, bb.top-200m);
                caron = box(bb.right-300m, bb.top-450m, bb.right+50m, bb.top+50m) }};


// Uppercase-eng variations
// (The extra composite glyphs aren't really needed, they only happen to be in the font for AAT.)
c_eng_Descender = (g__eng, g_eng_sc);                    // cno_BaselineHook = cno_Kom
c_eng_UCStyle = (g__eng_u_c_style, g_eng_u_c_style_sc);  // (g__eng_u_c_style, g014A0301_uCStyle, g014A0300_uCStyle, g014A0302_uCStyle, g014A0303_uCStyle, g014A0323_uCStyle);
c_eng_BaselineHook = (g__eng_baseline_hook, g_eng_baseline_hook_sc);  // cBaselineHook;
c_eng_Kom = (g__eng_kom, g_eng_kom_sc);                  // cKom;

// V-hook variations
c_vhook_Curved = cno_StraightLft; // = cno_StraightLftHighHook
c_vhook_StraightLeft = cStraightLft;
c_vhook_HighHook = cStraightLftHighHook;

// Cyrillic shha (uses same tag as uppercase eng so we define these clases by hand):
cUCStyleCyrShha = (g04bb_uCStyle);
cno_UCStyleCyrShha = (g04bb);

// We need to add these explicitly because makegdl does not recognize the fact that
// 'g_dotlessi_s_italic' needs to be in the cDotless class.
// TODO: recheck when we switch over to the new version of make_gdl.
cDotless += (g_dotlessi_s_ital); // g_dotlessi_tail_i;
cno_Dotless += (g_i_s_ital);     // g_i_tail_i;

// Same with tail-i and j-serif.
#if (ANDIKAfamily)
cDotless    += (g_dotlessi_tail_i	g0237_topLftSerif);
cno_Dotless += (g_i_tail_i			g_j_top_lft_serif);
#endif

// Same with the low-profile i and j.
#if (FONT == GENTIUMfont)
cDotless    += (g_i_dotless	g_j_dotless);
cno_Dotless += (g_i_l_p		g_j_l_p);

// Also handle converting low-profile i/j to small caps.
cno_sc	+= (g_i_l_p		g_j_l_p);
c_sc	+= (g_i_sc		g_j_sc);
#endif

#if (ANDIKAfamily)
// makegdl can't figure out that 'g_q_diag_tail_sc' needs to be in the cDiagTail class.
cno_DiagTail += (g_q_sc);
cDiagTail    += (g_q_diag_tail_sc);
#endif

cno_BrInvBreve = (g0311    g0361);
cBrInvBreve_uU = (g0311_uU g0361_uU);
cBrInvBreve_uL = (g0311_uL g0361_uL);
cBrInvBreve_lL = (g0311_lL g0361_lL);

cBridgeDiac = ( g0308_uU  g0308_uL  g0308_lL
				g0311_uU  g0311_uL  g0311_lL
				g0361_uU  g0361_uL  g0361_lL);


// Narrow characters that need a narrow macron.
// Since this subsitution is done in the first pass, we only need to include encoded glyphs.

c_narrowMacron = (g_i, g_l, g_r, g_t,
	g_igrave, g_iacute, g_icircumflex, g_idieresis, g_itilde, g_imacron, g_ibreve, g_iogonek, g_dotlessi,
	g_lacute, g_lcommaaccent, g_lcaron, g_ldot, g_lslash,
	g_racute, g_rcommaaccent, g_rcaron, g0163, g_tcaron, g_tbar, g0196, g019a, g01ad, g01d0, g0209,
	g020b, g0211, g0213, g021b,
	g0234, g0236 // l-curl, t-curl
	g024d, g0268, g0269, g026b, g026c, g026d, g027c, g027e, g0287, g0288,
	g1d72, g1d73, g1d75, g1d7c,
	g1d89,
	// g1e2d, g1e3d, g1e71, // i-lower-tilde, l-lower-circumflex, t-lower-circumflex
	g1e2f, g1e27, g1e39, g1e3b, g1e59, g1e5b, g1e5d, g1e5f, g1e6b, g1e6d, g1e6f, g1e97, g1ec9,
	g1ecb, g2c61, g2c66, ga749,
	ga772, ga775, ga777 // lum, rum, tum??
	ga77c, ga781, ga785, ga78e, ga7a7);
	
c_narrowLowerDiac = (g031c, g031d, g031e, g_dotbelowcomb, g0326, g0327, g0328, g0329, g032a, g0348);

/****
c_narrowMacron = (g_i,
	g_iacute, g_igrave, g_icircumflex, g_idieresis,
	g_i_s_ital, g0456, g2170, g_iacute_s_ital, g_igrave_s_ital, g0209,
	g0209_sItal, g_icircumflex_s_italic, g020b, g020b_sItal, g_ibreve, g_ibreve_s_ital,
	g01d0, g01d0_sItal, g_itilde, g_itilde_s_ital, g_imacron, g_imacron_s_ital,
	g_idieresis_s_ital, g0457, g1e2f, g1e2f_sItal, g_idotaccent, g_idotaccent_s_ital,
	g1ec9, g1ec9_sItal, g1e2d, g1e2d_sItal, g1ecb, g1ecb_sItal, g_iogonek,
	g_iogonek_retro_hook, g0268, g_i_dotless, g_dotlessi_s_ital, 
	g_i_dotless_s_ital, g0456_dotless, g1d96_dotless, g0268_dotless, g1d09, g0269, g1d7c,

	g_l, g_l_s_ital, g217c, g2097, g2097_sItal, g02e1, g_lacute, g_lacute_s_ital, g_lcaron_caron, g1e3d,
	g1e3d_sItal, g1e3b, g1e3b_sItal, g1e37, g1e37_sItal, g1e39, g1e39_sItal, g_lcommaaccent,
	g_ldot, g_lcaron, g1d85, g1daa, g019a, ga749, g2c61, g026b, g_lslash, g026d, g1da9, g0234, g026c, ga78e, ga749_sItal,
	ga747, ga781,
	
	g_r, g_racute, g_rcaron, ga758, g1d514, g1d63, g1dca, g02b3, g036c, g_racute, g0211,
	g0213, g_rcaron, g1e59, g1e5f, g1e5b, g027d_lCStyle, g027c, g02b4, g027b, g02b5,

	g_t, g_tcaron_caron, g1e97, g1e6b, g1e71, g1e6f, g1e6d, g021b, g_tcaron, g0163, g01ab, g1db5,
	g_tbar, g1d75 );
	

#if (FONT == ANDIKAfont)

c_narrowMacron += (g0269_0301, g0269_0300, g0269_1dc7, g0269_0302, g0269_030c, g0269_0303, g0269_1dc6, g0269_0330, 
	g_iogonek_tail_i_retro_hook, g0268_tailI, g0268_dotless_tailI, g_i_tail_i, g_dotlessi_tail_i,
	g_iacute_tail_i, g_igrave_tail_i, g0209_tailI, g_icircumflex_tail_i, g020b_tailI, g_ibreve_tail_i, g01d0_tailI,
	g_itilde_tail_i, g_imacron_tail_i, g1e2f_tailI, g_idieresis_tail_i, g1ec9_tailI, g1e2d_tailI, g1ecb_tailI,
	g_iogonek_tail_i, 
	
	g_lcaron_caron_tail_l, g_l_tail_l, g_lacute_tail_l, g1e3d_tailL, g1e3b_tailL, g1e37_tailL, g1e39_tailL,
	g_lcommaaccent_tail_l, g_ldot_tail_l, g_lcaron_tail_l, g1d85_tailL, g1daa_tailL, g019a_tailL, g2c61_tailL,
	g026b_tailL, g_lslash_tail_l, g026c_tailL, 

	g_tcaron_caron_no_tail_t, g0163_commaStyle_noTailT, g_t_no_tail_t, g1e97_noTailT, g1e6b_noTailT,
	g1e71_noTailT, g1e6f_noTailT, g1e6d_noTailT, g021b_noTailT, g_tcaron_no_tail_t, g0163_noTailT,
	g01ab_noTailT, g_tbar_no_tail_t, g1d75_noTailT, g2c66_noTailT);

#endif
****/

endtable; // glyph

// #include "pua.gdh"

#if (FONT == GENTIUMfont)
// Define the class of upper-case letters that need low-profile diacritics.
#include "takes_lowProfile.gdh"

table(glyph) {AttributeOverride = true}

cno_LP { lp_subclass = LP_BASEDIAC };
// The following glyphs have low-profile versions but do not have diacritics attached:
g_i  { lp_subclass = LP_BASEONLY };
g_j  { lp_subclass = LP_BASEONLY };
g_ij { lp_subclass = LP_BASEONLY };
// The following glyphs are just diacritics:
cUDia { lp_subclass = LP_DIACONLY };


// The following are lower-case glyphs with precomposed upper diacritics that have no low-profile equivalents.
// Any diacritics that stack on top of them should be low-profile.
c_lowerWnonLPdiacs = ( g_aring, g_abreve, g_ebreve, g_gbreve, g_ibreve, g_obreve,
	g_ohungarumlaut, g_ubreve, g_uhungarumlaut, g0201, g0203, g0205, g0207, g0209,
	g020b, g020d, g020f, g0211, g0213, g0215, g0217, g1e1d, g1e98, g1e99, g1e9a, g1ea3,
	g1eb7, g1ebb, g1ec9, g1ecf, g1edf, g1ee7, g1eed, g1ef7 );

endtable;

#endif	// (FONT == GENTIUMfont)


//////////////////////////////////////////////////////////////////////////////////////
//
//	Features
//

#include "features.gdh"


//////////////////////////////////////////////////////////////////////////////////////
//
//	Rules
//

#if (FONT == GENTIUMfont)
// Combine any possible decomposed Greek into composed forms.
#include "greek_recompose.gdh"	// pass 1
#endif


table(substitution);

pass(1)  {MaxBackup = 15; MaxRuleLoop = 30}

// Decomposition/reordering
// Also Greek recomposition is done in pass 1 (in greek_recompose.gdh above).
// Also pitch processing (pitches.gdh).

/* --- removed feature ---
c_pua  >  c_noPua {pua = 1}  /  ^ _ ;
-------------------------- */

// Decompose possible vietnamese base + diac
c_baseCircum  _  >  c_base_noDiac:1  g0302:1  / ^ _ _;
c_baseBreve   _  >  c_base_noDiac:1  g0306:1  / ^ _ _;

// For the special bridging diacritic stuff, upper diacritics need to come first so they will attach
// to the first base (0311 and 0361 seem to be treated differently by NFD).
if (bridging_diac)
	cLDblDia  cUDblDia   >   @2  @1;
endif;


// Narrow macrons

if (!smallcaps)
g0331  >  g0331_short  /  c_narrowMacron  c_narrowLowerDiac? _ ;
endif;

endpass;  // sub - 1

#if (ANDIKAfamily)
if (smallcaps || (literacy == 0))
#else
if (smallcaps || literacy )
#endif

pass(2)

// Small-caps, literacy alternates

if (smallcaps)
	cno_sc  > c_sc;
endif;


// NB: Because 01E5 is affected by two features, barred_bowl and literacy,
// these features take special organization of their rules. Specifically,
// 01E5 should be displayed as:
//	if Literacy Alternates then LtnSmGBarredSngBowl (uni01E5.BarBowl.SngBowl)
//	else if Barred-Bowl Forms then LtnSmGBarredBowl (uni01E5.BarBowl)
//	else LtnSmGStrk (uni01E5)
// Note also that uni01E5 doesn't show up in any class.


// Note: literacy alternates take precedence over slant-italic feature (below).
// So we can ignore slant-italics here.
if (literacy == 1)
	cno_SngBowl  > cSngBowl;		// (includes uni01E5.BarBowl > uni01E5.BarBowl.SngBowl)
	// g01e5_barBowl_sngBowl is conceptually equal to g01e5_sngBowl (since the forms are the same).
	// Don't add this correspondence to the SngBowl forms to avoid confusing the reverse rules below;
	// just use a separate rule:
	g01e5  >  g01e5_barBowl_sngBowl;

	cno_SngStory > cSngStory;

else
	cSngBowl  > cno_SngBowl;		// (includes uni01E5.BarBowl.SngBowl > uni01E5.BarBowl)
	cSngStory > cno_SngStory;	
endif;


endpass;  // sub - 2

#if (ANDIKAfamily)
endif; // pass constraint: if (small_caps || (literacy == 0))
#else
endif; // pass constraint: if (small_caps || literacy)
#endif

pass(3)  {MaxBackup = 15; MaxRuleLoop = 30}

// Many features: slant italic, Chinantec tones, ogoneks, cedillas, horns, Vietnamese, bridging diacritics,
// engs, ramshorn, mongolian E, short breve, barred bowls, strokes, open-o serif, v-hook, y-hook,
// ezh-curl, t-hook, b-hook, h-stroke, r-tail, p-hook, Romanian, ezh, apostrophe, modifier-low-colon,
// carons, ou, empty-set, cyrillic-shha, serbian, serif-beta, digit variations, Andika variations...
// Also pitch processing (in pitches.gdh).

// TODO: the code below will have to be extended somewhat to correctly handle the case where
// the slant-italic glyphs are the default.

if (slant_italic == 1)
	// ff, fi, fl ligatures
	g_f  cfLigC2  >  g_f_s_ital cfLigC2_sItal   / _ _ cDia;  // don't create a ligature, a following diac stops ligature from forming
	g_f  cfLigC2  >  _ cfLig_sItal:(1 2) {component {f1.ref = @1; f2.ref = @2}};

	g_f  g_f  cffLigC3  >  g_f_s_ital  g_f_s_ital  cffLigC3_sItal  / _ _ _ cDia;  // don't create a ligature
	g_f  g_f  cffLigC3  >  _ _  cffLig_sItal:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}};

	cno_SItal  >  cSItal;		// f, i, l, v
	cno_2StorySItal  >  c2StorySItal;  // a, ae
else
	// ff, fi, fl ligatures
	g_f  cfLigC2  >  @1 @2 / _ _ cDia; // do nothing, a following diac stops ligature from forming
	g_f  cfLigC2  >  _ cfLig:(1 2) {component {f1.ref = @1; f2.ref = @2}}
		/  _ ^ _ ;	// back up to handle i-alternates

	g_f  g_f  cffLigC3  >  @1 @2 @3 / _ _ _ cDia;  // do nothing
	g_f  g_f  cffLigC3  >  _ _ cffLig:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}}
		/  _  _ ^ _;	// back up to handle i-alternates
 
	cSItal        >  cno_SItal;
	c2StorySItal  >  cno_2StorySItal;
endif;


// Turn combining half-marks into one double-width combining mark
gfe20=d1  gfe21=d2  >  g0361:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;
gfe22=d1  gfe23=d2  >  g0360:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;

// For Chinantec, make the standard Unicode characters look like the special PUA characters.
if (chinantec_tone == 1)
	cno_ChinantecTn  >  cChinantecTn;
else
	cChinantecTn  >  cno_ChinantecTn;
endif;

// Handle ogoneks; backup needed to also handle literacy feature:
cOgonekBase  g0328  >  cOgonekComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnODiaX)  _=d;

// Handle cedillas (including those that need to look like comma-accent by precomposing them);
// back-up needed to also handle rom feature:
cCedillaBase  g0327  >  cCedillaComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnHDiaX)  _=d;
// Handle horns:
cHornBase  g031b  >  cHornComposite$1:(b d)  _ {passKeySlot = true}  /  _=b  DIASTR4(cnRDiaX)  _=d;

// Handle Vietnamese
/* jw comments
     2 stacked diacs go to side-by-side unless there is an intervening upper diac.
     pre-composed base + stacked diacs go to pre-composed base+side-by-side (cVN) */
if (viet == 1)
	// decompose the stacked form and replace the base 'a' with the literacy form,
	// the diacritics with the Vietnamese form
	_  c_aStack_noLit  >  g_a_sng_story:2  c_diacComb_vN / _ _ {literacy == 1};
	
	c0302_noVN  cDiac_noVN  >  c_0302_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;
	c0306_noVN  cDiac_noVN  >  c_0306_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;
	
	cno_VN > cVN; // ie, when literacy == false
else
	cVN > cno_VN;
endif;

table(glyph)
cls_l_lower = (g_l, g_l_sc);	// include small caps
cls_o_lower = (g_o, g_o_sc);
cls_u_lower = (g_u, g_u_sc);
endtable;

if (bridging_diac)
	// LL with bridging diaeresis (U+035F is possible intervening bridging underbar)
	g0308  >  g0308_uU  /  g__l  g035f?  _  g035f?  g__l;
	g0308  >  g0308_uL  /  g__l  g035f?  _  g035f?  cls_l_lower;
	g0308  >  g0308_lL  /  cls_l_lower  g035f?  _  g035f?  cls_l_lower;
  
	// OU with bridging inverted breve (0311 / 0361)
	cno_BrInvBreve  >  cBrInvBreve_uU  /  g__o  g035f?  _  g035f?  g__u;
	cno_BrInvBreve  >  cBrInvBreve_uL  /  g__o  g035f?  _  g035f?  cls_u_lower;
	cno_BrInvBreve  >  cBrInvBreve_lL  /  cls_o_lower  g035f?  _  g035f?  cls_u_lower;
endif;

#if DEBUG

if (debug == 1)
	g_question > g_one		/ DeBuG g_space g_e g_n g_g g_equal _ {eng == 0};
	g_question > g_two		/ DeBuG g_space g_e g_n g_g g_equal _ {eng == 1};
	g_question > g_three	/ DeBuG g_space g_e g_n g_g g_equal _ {eng == 2};
endif;

#endif  // DEBUG

/*
	NOTES:

	The rules are designed so that they work correctly no matter how the 
	default value for a feature is set. While this means the rules don't
	demand that the cmap and feature table agree on the default glyph, 
	the font will be more usable in non-GDL apps if they do agree.
	(One exception remaining is vietnamese processing -- so don't
	try to build a font with vietnamese on by default).

	If a glyph name extension (which is what drives the class names) is used 
	within more than one feature (e.g., .LrgBowl is used in the Rams horn alternate 
	and the Small ezh-curl alternate), then we cannot use the automatically generated
	class names (e.g., cLrgBowl and cno_LrgBowl), but rather must explicitly
	handle each glyph -- sigh.
*/

if (eng == descender)
	// for fonts with default = base, capital, or short:
	c_eng_BaselineHook  >  c_eng_Descender;
	c_eng_UCStyle       >  c_eng_Descender;
	c_eng_Kom           >  c_eng_Descender;
endif;
if (eng == base)
	// for fonts with default = descender, capital, or short:
	c_eng_Descender   >  c_eng_BaselineHook;
	c_eng_UCStyle     >  c_eng_BaselineHook;
	c_eng_Kom         >  c_eng_BaselineHook;
endif;
if (eng == capital)
	// for fonts with default = descender, base, or short:
	c_eng_Descender    >  c_eng_UCStyle;
	c_eng_BaselineHook >  c_eng_UCStyle;
	c_eng_Kom          >  c_eng_UCStyle;
endif;
if (eng == short)
	// for fonts with default = descender, capital, or base:
	c_eng_Descender    >  c_eng_Kom;
	c_eng_BaselineHook >  c_eng_Kom;
	c_eng_UCStyle      >  c_eng_Kom;
endif;

if (ramshorn == small)
	// for fonts with default = large or gamma
	(g0264_lrgBowl  g0264_gammaStyle) > g0264;
endif;
if (ramshorn == large)
	// for fonts with default = small or gamma
	(g0264 	g0264_gammaStyle)	> g0264_lrgBowl;
endif;
if (ramshorn == gamma)
	// for fonts with default = small or large
	(g0264  g0264_lrgBowl)		> g0264_gammaStyle;
endif

// supernum feature dealt with in pitches.gdh

if (mongol_e == 1)
	cno_MongolStyle > cMongolStyle;
else
	cMongolStyle >cno_MongolStyle;
endif;

#if 1 // FONT != DOULOSfont
/**** obsolete feature
if (cyr_curs_ital == 1)
	cno_Cursive  >  cCursive;
else
	cCursive  >  cno_Cursive;
endif;
****/
#endif // !DOULOSfont

if (short_breve == 1)
	cno_CyShortMrkAlt > cCyShortMrkAlt;
else
	cCyShortMrkAlt > cno_CyShortMrkAlt;
endif;

if (invis == 1)
	cno_ShowInv > cShowInv;
endif;


// --- literacy and slant_italic features moved from here. ---


// The barred_bowl rule must happen *after* the literacy rule
if (barred_bowl == 1)                   //  does contain g01E5, no such naming as uni01e5 or
                                        // uni anything. That is the Postscript Name from xml file.  jw 8/27/04
	cno_BarBowl  >  cBarBowl;	// (does NOT include uni01E5 > uni01E5.BarBowl)
//	g01e5  >  g01e5_barBowl;		        yes it does jw.  commented 8/31 
//					see: cno_BarBowl = (g0180, g_dcroat, g01e5);
else
	cBarBowl  >  cno_BarBowl;	// (does NOT include uni01E5.BarBowl > uni01E5)
//	g01e5_barBowl  >  g01e5;			yes it does jw
endif;

if (ltnjstroke == doubleSerif)
	cno_DblSerif  >  cDblSerif;
else
	cDblSerif  >  cno_DblSerif;
endif;

if (open_o == topSerif)
	cno_TopSerif  >  cTopSerif;
else
	cTopSerif  >  cno_TopSerif;
endif;

if (v_hook == curved)
	c_vhook_StraightLeft >  c_vhook_Curved;
	c_vhook_HighHook     >  c_vhook_Curved;
endif;
if (v_hook == straightLeft)
	c_vhook_Curved    >  c_vhook_StraightLeft;
	c_vhook_HighHook  >  c_vhook_StraightLeft;
endif;
if (v_hook == highHook)
	c_vhook_Curved       >  c_vhook_HighHook;
	c_vhook_StraightLeft >  c_vhook_HighHook;
endif;

if (y_hook == 1)
	cno_RtHookYhook  >  cRtHookYhook;
else
	cRtHookYhook  >  cno_RtHookYhook;
endif;

if (n_hook == 1)
	cno_LCStyleNhook  >  cLCStyleNhook;
else
	cLCStyleNhook  >  cno_LCStyleNhook;
endif;

if (ezh_curl == 1)
	g0293  >  g0293_lrgBowl;
else
	g0293_lrgBowl  >  g0293;
endif;

if (t_hook == 1)
	cno_RtHookThook  >  cRtHookThook;
else
	cRtHookThook  >  cno_RtHookThook;
endif;

if (b_hook == 1)
	cno_TopBarB  >  cTopBarB;
else
	cTopBarB  >  cno_TopBarB;
endif;

if (d_hook == 1)
	cno_TopBarD  >  cTopBarD;
else
	cTopBarD  >  cno_TopBarD;
endif;

if (h_stroke == 1)
	cno_VertStrk  >  cVertStrk;
	////cno_BarStem  >  cBarStem;
else
	cVertStrk  >  cno_VertStrk;
	////cBarStem  >  cno_BarStem;
endif;

if (r_tail == 1)
	cno_LCStyleRtail  >  cLCStyleRtail;
else
	cLCStyleRtail  >  cno_LCStyleRtail;
endif;

if (p_hook == 1)
	cno_BowlHook  >  cBowlHook;
else
	cBowlHook  >  cno_BowlHook;
endif;

/* --- removed feature ---
if (rom == 1)
	cno_CommaStyle  >  cCommaStyle;
else
	cCommaStyle  >  cno_CommaStyle;
endif;
-------------------------- */

if (ezh == 1)
	cno_RevSigmaStyle  >  cRevSigmaStyle;
else
	cRevSigmaStyle  >  cno_RevSigmaStyle;
endif;

// ogonek processing must be in pass 2

if (apostrophe == 1)
	cno_Lrg  >  cLrg;
else
	cLrg  >  cno_Lrg;
endif;

if (modlowcolon == wide)
  cno_Wide >  cWide;	// a789, was gf1e9
  //gf1e9  >  gf1e9_wide;
else
  cWide  >  cno_Wide;
  //gf1e9_wide  >  gf1e9;
endif;

if (caron == 0)
	// European caron combinations (feature OFF)
	//if (select_diac)
	//	cno_CaronEuro  g030c  >  _  cCaronEuro$1:(1 2) {comp {base.ref = @1; caron.ref = @2}; passKeySlot=1};
	//else
		cno_CaronEuro  g030c  >  _  cCaronEuro$1:(1 2) {passKeySlot=1};
	//endif;
endif;
if (caron == 1)
	// Non-European caron but NFC: decompose and use standard caron
	cCaronEuro  _  >  cno_CaronEuro:1  g030c:1;
endif;

if (ou == 1)
	cno_OpenTop  >  cOpenTop;
else
	cOpenTop  >  cno_OpenTop;
endif;

if (emptyset == 1)
	cno_SlashZero  >  cSlashZero;
else
	cSlashZero  >  cno_SlashZero;
endif;

/* --- Obsolete feature ---
if (ltnglottalstop == capHeight)
  g0294_lC  >  g0294;
else
  g0294  >  g0294_lC;
endif;
--------------------------- */

if (cyrillic_shha == 1)
	cno_UCStyleCyrShha  >  cUCStyleCyrShha;
else
	cUCStyleCyrShha  >  cno_UCStyleCyrShha;
endif;

if (serbian == 1)
	cno_Serb  >  cSerb;
else
	cSerb  >  cno_Serb;
endif;

#if (FONT == GENTIUMfont)

if (serif_beta == 1)
	cno_Serif  >  cSerif;
else
	cSerif  >  cno_Serif;
endif;

if (greek_circ == 1)
	cno_Por  >  cPor;
else
	cPor  >  cno_Por;
endif;

#endif // GENTIUMfont


#if (ANDIKAfamily)

if (zero == 1)
	cno_Slash  >  cSlash;
else
	cSlash  >  cno_Slash;
endif;

if (one == 1)
	cno_NoBase  >  cNoBase;
else
	cNoBase  >  cno_NoBase;
endif;

if (four == 1)
	cno_Open  >  cOpen;
else
	cOpen  >  cno_Open;
endif;

if (six_nine == 1)
	cno_Diag  > cDiag;
else
	cDiag  >  cno_Diag;
endif;

if (seven == 1)
	cno_Bar  >  cBar;
else
	cBar  >  cno_Bar;
endif;

if (i_hook == 1)
	cno_TailI  >  cTailI;
else
	cTailI  >  cno_TailI;
endif;

if (j_serif == 1)
	cno_TopLftSerif  >  cTopLftSerif;
else
	cTopLftSerif  >  cno_TopLftSerif;
endif;

// No-Tail-T, Tail-L - see below

if (q_diagtail == 1)
	cno_DiagTail  >  cDiagTail;
else
	cDiagTail  >  cno_DiagTail;
endif;

if (q_point == 1)
	cno_Point  >  cPoint;
else
	cPoint  >  cno_Point;
endif;


if (y_tail == 1)
	cno_NoTailY  > cNoTailY;
else
	cNoTailY  >  cno_NoTailY;
endif;

#endif	// ANDIKAfamily

endpass;  // sub - 3


pass(4)  {MaxBackup = 15; MaxRuleLoop = 30}	// substitution

// Low-profile diacritics, more Andika features, dotless i + diac, ogonek, superscript/subscript diac,...


#if (FONT == GENTIUMfont)

// Low-profile diacritics--do this after processing Vietnamese.

// All stacking diacritics should be low-profile.
// In each of these rules we back up to handle dotless stuff.

// Mark the upper diacritic as needing low-profile because it is in a stack:
cno_LP  cUDia  >  cLP  @U {needs_lp = 1}  / ^ _ {lp_subclass == LP_DIACONLY}  DIASTR4(cnUDiaX)  _=U;
cno_LP  >  cLP  /  ^ _ {needs_lp == 1};  // needs LP because it follows an LP-diac from rule above
cno_LP  >  cLP  /  cUDia ^ _ {lp_subclass == LP_DIACONLY};
cno_LP  >  cLP  / c_lowerWnonLPdiacs ^ _;	// eg, NFC e-breve+circumflex, w-ring+acute

// Make sure to use low-profile diacritics on any decomposed uppercase.
cno_LP  >  cLP  /  cTakesLPDiac  DIASTR4(cnUDiaX) ^ _ {lp_subclass == LP_DIACONLY} ;

// Don't try to do low-profile stuff with small-caps.
if (low_profile_diac && !smallcaps)
	cno_LP  >  cLP  / ^ _;	// back up to handle dotless stuff
endif;

#endif // GENTIUMfont


#if (ANDIKAfamily)

// Andika features that interact with other features

if (t_tail == 1)
	cno_NoTailT  >  cNoTailT;
else
	cNoTailT  >  cno_NoTailT;
endif;

if (l_hook == 1)
	cno_TailL  >  cTailL;
else
	cTailL  >  cno_TailL;
endif;

#endif // ANDIKAfamily


// Convert i to dotless i when followed by upper diacritic.

// decomposed sequences:
cno_Dotless  cUDia=D  >  cDotless  @D {passKeySlot=1}  /  _  ^  DIASTR4(cnUDiaX)  _=D;
// precomposed chars with i are done by decomposition:
cSpecialDotted  _  cUDia=D  >  g_i_dotless  cSpecialDottedDia$1:1  @D {passKeySlot=1} 
	/  _  _  ^  DIASTR4(cnUDiaX)  _=D; 

// Now that ogonek has been composed with its vowels, do retrohook style if wanted:

if (ogonek == americanist)
	cno_RetroHook > cRetroHook;
else
	cRetroHook > cno_RetroHook;
endif;

//	g__aogonek	> g__a g0328_retroHook:1;
//	g_aogonek	> g_a  g0328_retroHook:1;
//	g__eogonek	> g__e g0328_retroHook:1;
//	g_eogonek	> g_e  g0328_retroHook:1;
//	g__iogonek	> g__i g0328_retroHook:1;
//	g_iogonek_dotless > g_i_dotless g0328_retroHook:1;
//	g_iogonek	> g_i  g0328_retroHook:1;
//	g__uogonek	> g__u g0328_retroHook:1;
//	g_uogonek	> g_u  g0328_retroHook:1;
//	g01ea		> g__o g0328_retroHook:1;
//	g01eb		> g_o  g0328_retroHook:1;
//	g01ec		> g__omacron g0328_retroHook:1;
//	g01ed		> g_omacron  g0328_retroHook:1;
//	g_ogonek	> g_ogonek_retro_hook:1;
//	g0328		> g0328_retroHook:1;
//endif;


// Handle superscript/subscript diacritics; currently the only one of interest is a diaeresis:
cno_Sup  >  cSup  /  (cModSuper cModSub)  _;


/* --- removed feature ---
// Deprecated PUA

if (dep_pua == unicode51)
	cno_Dep51  >  cDep51  /  _ {pua==1};
endif;
if (dep_pua == unicode50)
	cno_Dep50  >  cDep50  /  _ {pua==1};
endif;
if (dep_pua == unicode41)
	cno_Dep41  >  cDep41  /  _ {pua==1};
endif;
if (dep_pua == unicode40)
	cno_Dep40  >  cDep40  /  _ {pua==1};
endif;
-------------------------- */


endpass;  // sub - 4


endtable; // substitution


#include "pitches.gdh"


table(positioning) {MUnits = 1000};

// Handle attachments

pass(1)

#define pos_rule(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}
#define pos_ruleSD(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; insert = 1; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}


//if (select_diac)
//	pos_ruleSD(cTakesHDia, cHDia, HS, HM, cnHDiaX);
//	pos_ruleSD(cTakesLDia, cLDia, LS, LM, cnLDiaX);
//	pos_ruleSD(cTakesODia, cODia, OS, OM, cnODiaX);
//	pos_ruleSD(cTakesRDia, cRDia, RS, RM, cnRDiaX);
//	pos_ruleSD(cTakesUDia, cUDia, US, UM, cnUDiaX);
//else
	pos_rule(cTakesHDia, cHDia, HS, HM, cnHDiaX);
	pos_rule(cTakesLDia, cLDia, LS, LM, cnLDiaX);
	pos_rule(cTakesODia, cODia, OS, OM, cnODiaX);
	pos_rule(cTakesRDia, cRDia, RS, RM, cnRDiaX);
	pos_rule(cTakesUDia, cUDia, US, UM, cnUDiaX);
//endif;


// Bridge diacritics handled by attachment need to have zero advance width,
// otherwise they push the second character out and away. (This wouldn't work if above
// we didn't reprocess attached diacritics using the ^ mechanism.)
cBridgeDiac {advance.x = 0}; 

endpass; // pos - 1


// Handle double-diacritics

pass(2)	// positioning

	// Double-diacritics above: the ".1" gives the bounding box of the attached cluster of
	// base + diacritics.

	// Something on both sides:
	cUDblDia {shift.y = max(@B.boundingbox.top.1, @A.boundingbox.top.1) - @D.boundingbox.bottom + 100m ; 
			shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
			/ cTakesUDia=B  DIASTR3(cDia)  cLDblDia?  _=D  DIASTR3(cDia)  cTakesUDia=A;
	// Beginning of line:
	cUDblDia {shift.y = @B.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ cTakesUDia=B  DIASTR5(cDia)  cLDblDia?  _=D;
	// End of line:
	cUDblDia {shift.y = @A.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ DIASTR5(cDia)  cLDblDia?  _=D  cTakesUDia=A;

endpass; // pos - 2


pass(3)

	// Double-diacritics below:

	// Special case for two bridging diacritics:
	g035f {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ; 
		  shift.x = (@A.boundingbox.width - @B.boundingbox.width)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ; 
		  shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = @B.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ cTakesLDia=B  DIASTR5(cDia)  cUDblDia?  _=D ;
	cLDblDia {shift.y = @A.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ DIASTR5(cDia)  cUDblDia?  _=D  cTakesLDia=A ;


endpass; // pos - 3

////#include "kern.gdh"

endtable; // positioning
